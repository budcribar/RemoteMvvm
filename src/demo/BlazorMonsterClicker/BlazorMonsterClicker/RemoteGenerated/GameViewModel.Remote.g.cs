// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

#nullable enable
using Grpc.Core;
using Grpc.Net.Client;
using MonsterClicker.ViewModels.Protos;
using MonsterClicker.ViewModels.RemoteClients;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Hosting;
using System.Diagnostics;
using System.Windows.Threading;
using PeakSWC.Mvvm.Remote;

namespace MonsterClicker.ViewModels
{
    public partial class GameViewModel : CommunityToolkit.Mvvm.ComponentModel.ObservableObject, IDisposable
    {
        private GameViewModelGrpcServiceImpl? _grpcService;
        private readonly Dispatcher _dispatcher;
        private IHost? _aspNetCoreHost;
        private GrpcChannel? _channel;
        private MonsterClicker.ViewModels.RemoteClients.GameViewModelRemoteClient? _remoteClient;
        public GameViewModel(ServerOptions options) : this()
        {
            if (options == null) throw new ArgumentNullException(nameof(options));
            _dispatcher = Dispatcher.CurrentDispatcher;            _grpcService = new GameViewModelGrpcServiceImpl(this);
            StartAspNetCoreServer(options);
        }
        private void StartAspNetCoreServer(ServerOptions options)
        {
            var builder = WebApplication.CreateBuilder();
            builder.Services.AddGrpc();
            builder.Services.AddCors(o => o.AddPolicy("AllowAll", builder =>
            {
                builder.AllowAnyOrigin()
                       .AllowAnyMethod()
                       .AllowAnyHeader()
                       .WithExposedHeaders("Grpc-Status", "Grpc-Message", "Grpc-Encoding", "Grpc-Accept-Encoding");
            }));
            builder.Services.AddSingleton(_grpcService!);
            builder.WebHost.ConfigureKestrel(kestrelOptions =>
            {
                kestrelOptions.ListenLocalhost(options.Port, listenOptions =>
                {
                    if (options.UseHttps)
                    {
                        listenOptions.UseHttps();
                        listenOptions.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http1AndHttp2;
                    }
                    else
                    {
                        listenOptions.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http1AndHttp2;
                    }
                });
            });
            var app = builder.Build();
            app.UseRouting();
            app.UseCors("AllowAll");
            app.UseGrpcWeb(new GrpcWebOptions { DefaultEnabled = true });
            app.MapGet("/status", () => "Server is running.");
            app.MapGrpcService<GameViewModelGrpcServiceImpl>()
               .EnableGrpcWeb()
               .RequireCors("AllowAll");
            _aspNetCoreHost = app;
            Task.Run(() => app.RunAsync());
        }
        public GameViewModel(ClientOptions options) : this()
        {
            if (options == null) throw new ArgumentNullException(nameof(options));
            _dispatcher = null!;
            _channel = GrpcChannel.ForAddress(options.Address);
            var client = new MonsterClicker.ViewModels.Protos.GameViewModelService.GameViewModelServiceClient(_channel);
            _remoteClient = new GameViewModelRemoteClient(client);
        }
        public async Task<GameViewModelRemoteClient> GetRemoteModel()
        {
            if (_remoteClient == null) throw new InvalidOperationException("Client options not provided");
            await _remoteClient.InitializeRemoteAsync();
            return _remoteClient;
        }
        public void Dispose()
        {
            _channel?.ShutdownAsync().GetAwaiter().GetResult();
            _aspNetCoreHost?.StopAsync().GetAwaiter().GetResult();
            _aspNetCoreHost?.Dispose();
        }
    }
}
