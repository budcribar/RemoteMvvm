using GrpcRemoteMvvmModelUtil;
using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RemoteMvvmTool.Generators;

public static class ViewModelPartialGenerator
{
    public static string Generate(string vmName, string protoNs, string serviceName, string vmNamespace, string clientNamespace, string baseClass, string runType = "wpf", bool hasParameterlessConstructor = true, List<PropertyInfo>? properties = null)
    {
        var sb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(sb);
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Grpc.Core;");
        sb.AppendLine("using Grpc.Net.Client;");
        sb.AppendLine($"using {protoNs};");
        sb.AppendLine($"using {clientNamespace};");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Collections.ObjectModel;");
        sb.AppendLine("using System.Collections.Specialized;");
        sb.AppendLine("using System.ComponentModel;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using Microsoft.AspNetCore.Hosting;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.Logging;");
        sb.AppendLine("using Microsoft.Extensions.Hosting;");
        if (runType == "wpf") sb.AppendLine("using System.Windows.Threading;");
        else if (runType == "winforms") sb.AppendLine("using System.Windows.Forms;");
        sb.AppendLine($"using PeakSWC.Mvvm.Remote;");
        sb.AppendLine();
        sb.AppendLine($"namespace {vmNamespace}");
        sb.AppendLine("{");
        string baseClause = string.IsNullOrWhiteSpace(baseClass) ? "" : baseClass;
        if (!string.IsNullOrWhiteSpace(baseClause))
            baseClause += ", IDisposable";
        else
            baseClause = "IDisposable";
        sb.AppendLine($"    public partial class {vmName} : {baseClause}");
        sb.AppendLine("    {");
        sb.AppendLine($"        private {vmName}GrpcServiceImpl? _grpcService;");
        if (runType == "wpf") sb.AppendLine("        private readonly Dispatcher _dispatcher;");
        else if (runType == "winforms") sb.AppendLine("        private readonly Control _dispatcher;");
        sb.AppendLine("        private IHost? _aspNetCoreHost;");
        sb.AppendLine("        private GrpcChannel? _channel;");
        sb.AppendLine($"        private {clientNamespace}.{vmName}RemoteClient? _remoteClient;");
        sb.AppendLine();

        // Generate nested property change event handlers if properties are provided
        if (properties != null && properties.Count > 0)
        {
            GenerateNestedPropertyChangeHandlers(sb, properties);
        }

        var serverCtorSuffix = hasParameterlessConstructor ? " : this()" : string.Empty;
        sb.AppendLine($"        public {vmName}(ServerOptions options){serverCtorSuffix}");
        sb.AppendLine("        {");
        sb.AppendLine("            if (options == null) throw new ArgumentNullException(nameof(options));");
        if (runType == "wpf")
        {
            sb.AppendLine("            _dispatcher = Dispatcher.CurrentDispatcher;");
            sb.AppendLine($"            _grpcService = new {vmName}GrpcServiceImpl(this, _dispatcher);");
        }
        else if (runType == "winforms")
        {
            sb.AppendLine("            _dispatcher = new Control();");
            sb.AppendLine("            _dispatcher.CreateControl();");
            sb.AppendLine($"            _grpcService = new {vmName}GrpcServiceImpl(this, _dispatcher);");
        }
        else
        {
            sb.AppendLine($"            _grpcService = new {vmName}GrpcServiceImpl(this);");
        }
        sb.AppendLine();

        // Generate constructor initialization for nested property change handling
        if (properties != null && properties.Count > 0)
        {
            GenerateConstructorEventWiring(sb, properties);
        }

        sb.AppendLine("            // Always use ASP.NET Core with Kestrel to support gRPC-Web");
        sb.AppendLine("            StartAspNetCoreServer(options);");
        sb.AppendLine("        }");

        sb.AppendLine();
        sb.AppendLine("        private void StartAspNetCoreServer(ServerOptions options)");
        sb.AppendLine("        {");
        sb.AppendLine("            var builder = WebApplication.CreateBuilder();");
        sb.AppendLine();
        sb.AppendLine("            // Add services to the container");
        sb.AppendLine("            builder.Services.AddGrpc();");
        sb.AppendLine();
        sb.AppendLine("            // Add CORS support for gRPC-Web");
        sb.AppendLine("            builder.Services.AddCors(o => o.AddPolicy(\"AllowAll\", builder =>");
        sb.AppendLine("            {");
        sb.AppendLine("                builder.AllowAnyOrigin()");
        sb.AppendLine("                       .AllowAnyMethod()");
        sb.AppendLine("                       .AllowAnyHeader()");
        sb.AppendLine("                       .WithExposedHeaders(\"Grpc-Status\", \"Grpc-Message\", \"Grpc-Encoding\", \"Grpc-Accept-Encoding\");");
        sb.AppendLine("            }));");
        sb.AppendLine();
        sb.AppendLine("            // Register the gRPC service implementation with ASP.NET Core DI");
        sb.AppendLine("            builder.Services.AddSingleton(_grpcService!);");
        sb.AppendLine();
        sb.AppendLine("            // Configure Kestrel to listen on the specified port with HTTP/2 support");
        sb.AppendLine("            builder.WebHost.ConfigureKestrel(kestrelOptions =>");
        sb.AppendLine("            {");
        sb.AppendLine("                kestrelOptions.ListenLocalhost(options.Port, listenOptions =>");
        sb.AppendLine("                {");
        sb.AppendLine("                    listenOptions.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http1AndHttp2;");
        sb.AppendLine("                });");
        sb.AppendLine("            });");
        sb.AppendLine();
        sb.AppendLine("            // Build the application");
        sb.AppendLine("            var app = builder.Build();");
        sb.AppendLine();
        sb.AppendLine("            // Configure the HTTP request pipeline");
        sb.AppendLine("            app.UseRouting();");
        sb.AppendLine();
        sb.AppendLine("            // Use CORS middleware");
        sb.AppendLine("            app.UseCors(\"AllowAll\");");
        sb.AppendLine();
        sb.AppendLine("            // Enable gRPC-Web middleware");
        sb.AppendLine("            app.UseGrpcWeb(new GrpcWebOptions { DefaultEnabled = true });");
        sb.AppendLine();
        sb.AppendLine("            // Map gRPC services");
        sb.AppendLine($"            app.MapGrpcService<{vmName}GrpcServiceImpl>()");
        sb.AppendLine("               .EnableGrpcWeb()");
        sb.AppendLine("               .RequireCors(\"AllowAll\");");
        sb.AppendLine();
        sb.AppendLine("            // Start the server");
        sb.AppendLine("            _aspNetCoreHost = app;");
        sb.AppendLine("            Task.Run(() => app.RunAsync()); // Run the server in a background thread");
        sb.AppendLine("        }");
        sb.AppendLine();
        var clientCtorSuffix = hasParameterlessConstructor ? " : this()" : string.Empty;
        sb.AppendLine($"        public {vmName}(ClientOptions options){clientCtorSuffix}");
        sb.AppendLine("        {");
        sb.AppendLine("            if (options == null) throw new ArgumentNullException(nameof(options));");
        if (runType == "wpf" || runType == "winforms") sb.AppendLine("            _dispatcher = null!;");
        sb.AppendLine("            _channel = GrpcChannel.ForAddress(options.Address);");
        sb.AppendLine($"            var client = new {serviceName}.{serviceName}Client(_channel);");
        sb.AppendLine($"            _remoteClient = new {vmName}RemoteClient(client);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine($"        public async Task<{vmName}RemoteClient> GetRemoteModel()");
        sb.AppendLine("        {");
        sb.AppendLine("            if (_remoteClient == null) throw new InvalidOperationException(\"Client options not provided\");");  
        sb.AppendLine("            await _remoteClient.InitializeRemoteAsync();");
        sb.AppendLine("            return _remoteClient;");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        public void Dispose()");
        sb.AppendLine("        {");
        sb.AppendLine("            _channel?.ShutdownAsync().GetAwaiter().GetResult();");
        sb.AppendLine("            _aspNetCoreHost?.StopAsync().GetAwaiter().GetResult();");
        sb.AppendLine("            _aspNetCoreHost?.Dispose();");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void GenerateNestedPropertyChangeHandlers(StringBuilder sb, List<PropertyInfo> properties)
    {
        var collectionsNeedingHandlers = GetCollectionsNeedingEventHandlers(properties);
        
        foreach (var collection in collectionsNeedingHandlers)
        {
            var propName = collection.Name;
            var elementTypeName = GetElementTypeName(collection.FullTypeSymbol!);
            
            sb.AppendLine($"        // Auto-generated nested property change handlers for {propName}");
            sb.AppendLine($"        private void {propName}_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (e.NewItems != null)");
            sb.AppendLine($"                foreach ({elementTypeName} item in e.NewItems)");
            sb.AppendLine($"                    item.PropertyChanged += {propName}_ItemPropertyChanged;");
            sb.AppendLine("            if (e.OldItems != null)");
            sb.AppendLine($"                foreach ({elementTypeName} item in e.OldItems)");
            sb.AppendLine($"                    item.PropertyChanged -= {propName}_ItemPropertyChanged;");
            sb.AppendLine("        }");
            sb.AppendLine();
            sb.AppendLine($"        private void {propName}_ItemPropertyChanged(object? sender, PropertyChangedEventArgs e)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var index = {propName}.IndexOf(({elementTypeName})sender!);");
            sb.AppendLine($"            OnPropertyChanged($\"{propName}[{{index}}].{{e.PropertyName}}\");");
            sb.AppendLine("        }");
            sb.AppendLine();
        }
    }

    private static void GenerateConstructorEventWiring(StringBuilder sb, List<PropertyInfo> properties)
    {
        var collectionsNeedingHandlers = GetCollectionsNeedingEventHandlers(properties);
        
        if (collectionsNeedingHandlers.Count > 0)
        {
            sb.AppendLine("            // Auto-generated event wiring for nested property changes");
            foreach (var collection in collectionsNeedingHandlers)
            {
                var propName = collection.Name;
                sb.AppendLine($"            {propName}.CollectionChanged += {propName}_CollectionChanged;");
            }
            sb.AppendLine();
        }
    }

    private static List<PropertyInfo> GetCollectionsNeedingEventHandlers(List<PropertyInfo> properties)
    {
        var result = new List<PropertyInfo>();
        
        foreach (var prop in properties)
        {
            if (IsObservableCollectionOfNotifyingElements(prop.FullTypeSymbol!))
            {
                result.Add(prop);
            }
        }
        
        return result;
    }

    private static bool IsObservableCollectionOfNotifyingElements(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is not INamedTypeSymbol namedType) return false;
        
        // Check if it's ObservableCollection<T>
        if (!namedType.IsGenericType) return false;
        var genericTypeDefinition = namedType.ConstructedFrom.ToDisplayString();
        if (genericTypeDefinition != "System.Collections.ObjectModel.ObservableCollection<T>") return false;
        
        // Check if T implements INotifyPropertyChanged
        var elementType = namedType.TypeArguments[0];
        return ImplementsINotifyPropertyChanged(elementType);
    }

    private static bool ImplementsINotifyPropertyChanged(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is not INamedTypeSymbol namedType) return false;
        
        // Check all interfaces
        var allInterfaces = namedType.AllInterfaces;
        return allInterfaces.Any(i => i.ToDisplayString() == "System.ComponentModel.INotifyPropertyChanged");
    }

    private static string GetElementTypeName(ITypeSymbol collectionType)
    {
        if (collectionType is INamedTypeSymbol namedType && namedType.IsGenericType)
        {
            var elementType = namedType.TypeArguments[0];
            return elementType.ToDisplayString();
        }
        return "object";
    }
}
