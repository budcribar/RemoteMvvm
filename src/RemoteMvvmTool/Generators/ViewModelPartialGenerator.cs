using GrpcRemoteMvvmModelUtil;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RemoteMvvmTool.Generators;

public static class ViewModelPartialGenerator
{
    public static string Generate(string vmName, string protoNs, string serviceName, string vmNamespace, string clientNamespace, string baseClass, string runType = "wpf", bool hasParameterlessConstructor = true, List<PropertyInfo>? properties = null)
    {
        var sb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(sb);

        // Extract variables for raw string interpolation
        var vmNameVar = vmName;
        var protoNsVar = protoNs;
        var serviceNameVar = serviceName;
        var vmNamespaceVar = vmNamespace;
        var clientNamespaceVar = clientNamespace;
        var baseClassVar = baseClass;
        var runTypeVar = runType;
        var hasParameterlessConstructorVar = hasParameterlessConstructor;

        // Determine base clause
        var baseClause = string.IsNullOrWhiteSpace(baseClassVar) ? "" : baseClassVar;
        if (!string.IsNullOrWhiteSpace(baseClause))
            baseClause += ", IDisposable";
        else
            baseClause = "IDisposable";

        // Determine constructor suffixes
        var serverCtorSuffix = hasParameterlessConstructorVar ? " : this()" : string.Empty;
        var clientCtorSuffix = hasParameterlessConstructorVar ? " : this()" : string.Empty;

        // Determine dispatcher field
        var dispatcherField = runTypeVar switch
        {
            "wpf" => "        private readonly Dispatcher _dispatcher;",
            "winforms" => "        private readonly SystemForms.Control _dispatcher;",
            _ => ""
        };

        // Determine dispatcher initialization
        var dispatcherInit = runTypeVar switch
        {
            "wpf" => "            _dispatcher = Dispatcher.CurrentDispatcher;",
            "winforms" => $$"""
            _dispatcher = new SystemForms.Control();
            _dispatcher.CreateControl();
""",
            _ => ""
        };

        // Determine client dispatcher initialization
        var clientDispatcherInit = (runTypeVar == "wpf" || runTypeVar == "winforms") ? "            _dispatcher = null!;" : "";

        // Determine WPF/WinForms using statement
        var platformUsing = runTypeVar switch
        {
            "wpf" => "using System.Windows.Threading;",
            "winforms" => "using SystemForms = System.Windows.Forms;",
            _ => ""
        };

        // Generate nested property change handlers and constructor wiring if needed
        var nestedPropertyHandlers = "";
        var constructorEventWiring = "";

        if (properties != null && properties.Count > 0)
        {
            var handlersSb = new StringBuilder();
            GenerateNestedPropertyChangeHandlers(handlersSb, properties);
            nestedPropertyHandlers = handlersSb.ToString();

            var wiringSb = new StringBuilder();
            GenerateConstructorEventWiring(wiringSb, properties);
            constructorEventWiring = wiringSb.ToString();
        }

        sb.AppendLine($$"""
#nullable enable
using Grpc.Core;
using Grpc.Net.Client;
using {{protoNsVar}};
using {{clientNamespaceVar}};
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Hosting;
using System.Diagnostics;
{{platformUsing}}
using PeakSWC.Mvvm.Remote;

namespace {{vmNamespaceVar}}
{
    public partial class {{vmNameVar}} : {{baseClause}}
    {
        private {{vmNameVar}}GrpcServiceImpl? _grpcService;
        {{dispatcherField}}
        private IHost? _aspNetCoreHost;
        private GrpcChannel? _channel;
        private {{clientNamespaceVar}}.{{vmNameVar}}RemoteClient? _remoteClient;
        {{nestedPropertyHandlers}}
        public {{vmNameVar}}(ServerOptions options){{serverCtorSuffix}}
        {
            if (options == null) throw new ArgumentNullException(nameof(options));
            {{dispatcherInit}}
            // Always create service without dispatcher - MVVM Toolkit handles threading automatically
            _grpcService = new {{vmNameVar}}GrpcServiceImpl(this, null);
            {{constructorEventWiring}}
            // Always use ASP.NET Core with Kestrel to support gRPC-Web
            StartAspNetCoreServer(options);
        }

        private void StartAspNetCoreServer(ServerOptions options)
        {
            var builder = WebApplication.CreateBuilder();

            // Add services to the container
            builder.Services.AddGrpc();

            // Add CORS support for gRPC-Web
            builder.Services.AddCors(o => o.AddPolicy("AllowAll", builder =>
            {
                builder.AllowAnyOrigin()
                       .AllowAnyMethod()
                       .AllowAnyHeader()
                       .WithExposedHeaders("Grpc-Status", "Grpc-Message", "Grpc-Encoding", "Grpc-Accept-Encoding");
            }));

            // Register the gRPC service implementation with ASP.NET Core DI
            builder.Services.AddSingleton(_grpcService!);

            // Configure Kestrel to listen on the specified port with HTTP/2 support
            builder.WebHost.ConfigureKestrel(kestrelOptions =>
            {
                // HTTP endpoint for compatibility (HTTP/1.1 + HTTP/2)
                kestrelOptions.ListenLocalhost(options.Port, listenOptions =>
                {
                    listenOptions.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http1AndHttp2;
                });

                // HTTPS endpoint for proper gRPC streaming (HTTP/2 only)
                kestrelOptions.ListenLocalhost(options.Port + 1000, listenOptions =>
                {
                    listenOptions.UseHttps(); // Use development certificate
                    listenOptions.Protocols = Microsoft.AspNetCore.Server.Kestrel.Core.HttpProtocols.Http2;
                });
            });

            // Build the application
            var app = builder.Build();

            // Configure the HTTP request pipeline
            app.UseRouting();

            // Use CORS middleware
            app.UseCors("AllowAll");

            // Enable gRPC-Web middleware
            app.UseGrpcWeb(new GrpcWebOptions { DefaultEnabled = true });

            // Map gRPC services
            app.MapGrpcService<{{vmNameVar}}GrpcServiceImpl>()
               .EnableGrpcWeb()
               .RequireCors("AllowAll");

            // Start the server
            _aspNetCoreHost = app;
            Task.Run(() => app.RunAsync()); // Run the server in a background thread
        }

        public {{vmNameVar}}(ClientOptions options){{clientCtorSuffix}}
        {
            if (options == null) throw new ArgumentNullException(nameof(options));
            {{clientDispatcherInit}}
            _channel = GrpcChannel.ForAddress(options.Address);
            var client = new {{protoNsVar}}.{{serviceNameVar}}.{{serviceNameVar}}Client(_channel);
            _remoteClient = new {{vmNameVar}}RemoteClient(client);
        }

        public async Task<{{vmNameVar}}RemoteClient> GetRemoteModel()
        {
            if (_remoteClient == null) throw new InvalidOperationException("Client options not provided");
            await _remoteClient.InitializeRemoteAsync();
            return _remoteClient;
        }

        public void Dispose()
        {
            _channel?.ShutdownAsync().GetAwaiter().GetResult();
            _aspNetCoreHost?.StopAsync().GetAwaiter().GetResult();
            _aspNetCoreHost?.Dispose();
        }
    }
}
""");
        return sb.ToString();
    }

    private static void GenerateNestedPropertyChangeHandlers(StringBuilder sb, List<PropertyInfo> properties)
    {
        var collectionsNeedingHandlers = GetCollectionsNeedingEventHandlers(properties);

        foreach (var collection in collectionsNeedingHandlers)
        {
            var propName = collection.Name;
            var elementTypeName = GetElementTypeName(collection.FullTypeSymbol!);

            sb.AppendLine($$"""
        // Auto-generated nested property change handlers for {{propName}}
        private void {{propName}}_CollectionChanged(object? sender, NotifyCollectionChangedEventArgs e)
        {
            if (e.NewItems != null)
                foreach ({{elementTypeName}} item in e.NewItems)
                    item.PropertyChanged += {{propName}}_ItemPropertyChanged;
            if (e.OldItems != null)
                foreach ({{elementTypeName}} item in e.OldItems)
                    item.PropertyChanged -= {{propName}}_ItemPropertyChanged;
        }

        private void {{propName}}_ItemPropertyChanged(object? sender, PropertyChangedEventArgs e)
        {
            var index = {{propName}}.IndexOf(({{elementTypeName}})sender!);
""");
            sb.AppendLine($"            OnPropertyChanged($\"{{{propName}}}[{{index}}].{{e.PropertyName}}\");");
            sb.AppendLine($$"""
        }

""");
        }
    }

    private static void GenerateConstructorEventWiring(StringBuilder sb, List<PropertyInfo> properties)
    {
        var collectionsNeedingHandlers = GetCollectionsNeedingEventHandlers(properties);

        if (collectionsNeedingHandlers.Count > 0)
        {
            sb.AppendLine("            // Auto-generated event wiring for nested property changes");
            foreach (var collection in collectionsNeedingHandlers)
            {
                var propName = collection.Name;
                sb.AppendLine($"            {propName}.CollectionChanged += {propName}_CollectionChanged;");
            }
            sb.AppendLine();
        }
    }

    private static List<PropertyInfo> GetCollectionsNeedingEventHandlers(List<PropertyInfo> properties)
    {
        var result = new List<PropertyInfo>();
        
        foreach (var prop in properties)
        {
            if (IsObservableCollectionOfNotifyingElements(prop.FullTypeSymbol!))
            {
                result.Add(prop);
            }
        }
        
        return result;
    }

    private static bool IsObservableCollectionOfNotifyingElements(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is not INamedTypeSymbol namedType) return false;
        
        // Check if it's ObservableCollection<T>
        if (!namedType.IsGenericType) return false;
        var genericTypeDefinition = namedType.ConstructedFrom.ToDisplayString();
        if (genericTypeDefinition != "System.Collections.ObjectModel.ObservableCollection<T>") return false;
        
        // Check if T implements INotifyPropertyChanged
        var elementType = namedType.TypeArguments[0];
        return ImplementsINotifyPropertyChanged(elementType);
    }

    private static bool ImplementsINotifyPropertyChanged(ITypeSymbol typeSymbol)
    {
        if (typeSymbol is not INamedTypeSymbol namedType) return false;
        
        // Check all interfaces
        var allInterfaces = namedType.AllInterfaces;
        return allInterfaces.Any(i => i.ToDisplayString() == "System.ComponentModel.INotifyPropertyChanged");
    }

    private static string GetElementTypeName(ITypeSymbol collectionType)
    {
        if (collectionType is INamedTypeSymbol namedType && namedType.IsGenericType)
        {
            var elementType = namedType.TypeArguments[0];
            return elementType.ToDisplayString();
        }
        return "object";
    }
}
