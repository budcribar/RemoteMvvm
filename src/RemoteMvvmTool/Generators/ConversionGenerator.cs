using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GrpcRemoteMvvmModelUtil;

namespace RemoteMvvmTool.Generators;

public static class ConversionGenerator
{
    public static string Generate(string protoNs, string viewModelNs, IEnumerable<ITypeSymbol> rootTypes, Compilation compilation)
    {
        var methods = new StringBuilder();
        var processed = new HashSet<string>();
        bool needsTimestamp = false;
        foreach (var t in rootTypes)
            GenerateForType(t, methods, processed, protoNs, compilation, ref needsTimestamp);

        var headerSb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(headerSb);

        var additionalUsings = new StringBuilder();
        if (needsTimestamp)
        {
            additionalUsings.AppendLine("using System;");
            additionalUsings.AppendLine("using Google.Protobuf.WellKnownTypes;");
        }

        var template = GeneratorHelpers.LoadTemplate("RemoteMvvmTool.Resources.ConversionTemplate.tmpl");
        return GeneratorHelpers.ReplacePlaceholders(template, new Dictionary<string, string>
        {
            ["<<AUTO_GENERATED_HEADER>>"] = headerSb.ToString().TrimEnd(),
            ["<<PROTO_NS>>"] = protoNs,
            ["<<NAMESPACE>>"] = viewModelNs,
            ["<<ADDITIONAL_USINGS>>"] = additionalUsings.ToString(),
            ["<<CONVERSION_METHODS>>"] = methods.ToString(),
        });
    }

    static bool IsEnumType(ITypeSymbol type, Compilation compilation)
    {
        if (type.TypeKind == TypeKind.Enum)
            return true;
        if (type.TypeKind == TypeKind.Error)
        {
            var match = compilation.GetSymbolsWithName(type.Name, SymbolFilter.Type)
                .OfType<INamedTypeSymbol>()
                .FirstOrDefault(s => s.ToDisplayString() == type.ToDisplayString() && s.TypeKind == TypeKind.Enum);
            return match != null;
        }
        return false;
    }

    static bool IsDateTime(ITypeSymbol type, out bool isNullable)
    {
        isNullable = false;
        if (type.SpecialType == SpecialType.System_DateTime || type.ToDisplayString() == "System.DateTime")
            return true;
        if (type is INamedTypeSymbol named && named.IsGenericType &&
            named.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
            named.TypeArguments.Length == 1)
        {
            var inner = named.TypeArguments[0];
            if (inner.SpecialType == SpecialType.System_DateTime || inner.ToDisplayString() == "System.DateTime")
            {
                isNullable = true;
                return true;
            }
        }
        return false;
    }

    static void GenerateForType(ITypeSymbol type, StringBuilder sb, HashSet<string> processed, string protoNs, Compilation compilation, ref bool needsTimestamp)
    {
        if (type is null) return;
        if (IsEnumType(type, compilation)) { processed.Add(type.ToDisplayString()); return; }
        if (type is IArrayTypeSymbol arr) { GenerateForType(arr.ElementType, sb, processed, protoNs, compilation, ref needsTimestamp); return; }
        if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var keyType, out var valueType)) { if (keyType != null) GenerateForType(keyType, sb, processed, protoNs, compilation, ref needsTimestamp); if (valueType != null) GenerateForType(valueType, sb, processed, protoNs, compilation, ref needsTimestamp); return; }
        if (GeneratorHelpers.TryGetEnumerableElementType(type, out var elemType)) { if (elemType != null) GenerateForType(elemType, sb, processed, protoNs, compilation, ref needsTimestamp); return; }
        if (type is not INamedTypeSymbol named) return;
        var fullName = named.ToDisplayString();
        if (processed.Contains(fullName)) return;
        if (GeneratorHelpers.IsWellKnownType(named)) return;
        processed.Add(fullName);
        
        // Collect all nested types that need to be generated BEFORE generating this type's methods
        var nestedTypes = new List<ITypeSymbol>();
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.GetMethod == null) continue;
            var propType = prop.Type;
            
            if (GeneratorHelpers.TryGetDictionaryTypeArgs(propType, out var keyT, out var valT))
            {
                if (valT != null && !GeneratorHelpers.IsWellKnownType(valT))
                    nestedTypes.Add(valT);
            }
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                if (elem != null && !GeneratorHelpers.IsWellKnownType(elem))
                    nestedTypes.Add(elem);
            }
            else if (!GeneratorHelpers.IsWellKnownType(propType))
            {
                nestedTypes.Add(propType);
            }
        }
        
        // Generate nested types first
        foreach (var nestedType in nestedTypes)
        {
            GenerateForType(nestedType, sb, processed, protoNs, compilation, ref needsTimestamp);
        }
        
        // Now generate methods for this type
        string stateName = named.Name + "State";
        sb.AppendLine($"    public static {protoNs}.{stateName} ToProto({fullName} model)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var state = new {protoNs}.{stateName}();");
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.GetMethod == null) continue;
            var propType = prop.Type;
            string propName = prop.Name;
            if (IsEnumType(propType, compilation))
                sb.AppendLine($"        state.{propName} = (int)model.{propName};");
            else if (IsDateTime(propType, out var propNullable))
            {
                needsTimestamp = true;
                if (propNullable)
                    sb.AppendLine($"        if (model.{propName} != null) state.{propName} = Timestamp.FromDateTime(model.{propName}.Value.ToUniversalTime());");
                else
                    sb.AppendLine($"        state.{propName} = Timestamp.FromDateTime(model.{propName}.ToUniversalTime());");
            }
            else if (GeneratorHelpers.TryGetDictionaryTypeArgs(propType, out var keyT, out var valT))
            {
                string keySel = IsEnumType(keyT!, compilation) ? "kv.Key" : "kv.Key";
                if (IsEnumType(keyT!, compilation)) keySel = $"(int){keySel}";
                string valSel;
                if (IsEnumType(valT!, compilation)) valSel = $"(int)kv.Value";
                else if (IsDateTime(valT!, out var vNullable)) { needsTimestamp = true; valSel = vNullable ? "Timestamp.FromDateTime(kv.Value.Value.ToUniversalTime())" : "Timestamp.FromDateTime(kv.Value.ToUniversalTime())"; }
                else if (!GeneratorHelpers.IsWellKnownType(valT!)) valSel = "ToProto(kv.Value)";
                else valSel = "kv.Value";
                sb.AppendLine($"        if (model.{propName} != null) state.{propName}.Add(model.{propName}.ToDictionary(kv => {keySel}, kv => {valSel}));");
            }
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                string sel = string.Empty;
                if (elem != null)
                {
                    if (IsEnumType(elem, compilation))
                        sel = ".Select(e => (int)e)";
                    else if (IsDateTime(elem, out var elemNullable))
                    {
                        needsTimestamp = true;
                        sel = elemNullable ? ".Select(e => Timestamp.FromDateTime(e.Value.ToUniversalTime()))" : ".Select(e => Timestamp.FromDateTime(e.ToUniversalTime()))";
                    }
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                        sel = ".Select(ToProto)";
                }
                sb.AppendLine($"        if (model.{propName} != null) state.{propName}.AddRange(model.{propName}{sel});");
            }
            else if (GeneratorHelpers.IsWellKnownType(propType))
                sb.AppendLine($"        state.{propName} = model.{propName};");
            else
            {
                sb.AppendLine($"        state.{propName} = ToProto(model.{propName});");
            }
        }
        sb.AppendLine("        return state;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static {fullName} FromProto({protoNs}.{stateName} state)");
        sb.AppendLine("    {");
        string initializer = named.TypeKind == TypeKind.Interface ? $"default({fullName})!" : $"new {fullName}()";
        sb.AppendLine($"        var model = {initializer};");
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.SetMethod == null || prop.SetMethod.DeclaredAccessibility != Accessibility.Public) continue;
            var propType = prop.Type;
            string propName = prop.Name;
            if (IsEnumType(propType, compilation))
                sb.AppendLine($"        model.{propName} = ({propType.ToDisplayString()})state.{propName};");
            else if (IsDateTime(propType, out var propNullable))
            {
                needsTimestamp = true;
                if (propNullable)
                    sb.AppendLine($"        model.{propName} = state.{propName}?.ToDateTime();");
                else
                    sb.AppendLine($"        model.{propName} = state.{propName}?.ToDateTime() ?? DateTime.MinValue;");
            }
            else if (GeneratorHelpers.TryGetDictionaryTypeArgs(propType, out var keyT, out var valT))
            {
                string keySel = IsEnumType(keyT!, compilation) ? $"({keyT!.ToDisplayString()})kv.Key" : "kv.Key";
                string valSel;
                if (IsEnumType(valT!, compilation)) valSel = $"({valT!.ToDisplayString()})kv.Value";
                else if (IsDateTime(valT!, out var vNullable)) { needsTimestamp = true; valSel = vNullable ? "kv.Value?.ToDateTime()" : "kv.Value.ToDateTime()"; }
                else if (!GeneratorHelpers.IsWellKnownType(valT!)) valSel = "FromProto(kv.Value)";
                else valSel = "kv.Value";
                sb.AppendLine($"        model.{propName} = state.{propName}.ToDictionary(kv => {keySel}, kv => {valSel});");
            }
            else if (propType is IArrayTypeSymbol arrType)
            {
                string sel = string.Empty;
                var arrElem = arrType.ElementType;
                if (IsEnumType(arrElem, compilation)) sel = ".Select(e => (" + arrElem.ToDisplayString() + ")e)";
                else if (IsDateTime(arrElem, out var elemNullable)) { needsTimestamp = true; sel = elemNullable ? ".Select(e => e?.ToDateTime())" : ".Select(e => e.ToDateTime())"; }
                else if (!GeneratorHelpers.IsWellKnownType(arrElem)) sel = ".Select(FromProto)";
                sb.AppendLine($"        model.{propName} = state.{propName}{sel}.ToArray();");
            }
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                string sel = string.Empty;
                if (elem != null)
                {
                    if (IsEnumType(elem, compilation))
                        sel = ".Select(e => (" + elem.ToDisplayString() + ")e)";
                    else if (IsDateTime(elem, out var elemNullable))
                    {
                        needsTimestamp = true;
                        sel = elemNullable ? ".Select(e => e?.ToDateTime())" : ".Select(e => e.ToDateTime())";
                    }
                    else if (!GeneratorHelpers.IsWellKnownType(elem)) sel = ".Select(FromProto)";
                }
                sb.AppendLine($"        model.{propName} = state.{propName}{sel}.ToList();");
            }
            else if (GeneratorHelpers.IsWellKnownType(propType))
                sb.AppendLine($"        model.{propName} = state.{propName};");
            else
            {
                sb.AppendLine($"        model.{propName} = FromProto(state.{propName});");
            }
        }
        sb.AppendLine("        return model;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }
}
