using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GrpcRemoteMvvmModelUtil;

namespace RemoteMvvmTool.Generators;

public static class ConversionGenerator
{
    public static string Generate(string protoNs, string viewModelNs, IEnumerable<ITypeSymbol> rootTypes, Compilation compilation)
    {
        var sb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(sb);
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine($"using {protoNs};");
        sb.AppendLine();
        sb.AppendLine($"namespace {viewModelNs};");
        sb.AppendLine();
        sb.AppendLine("public static class ProtoStateConverters");
        sb.AppendLine("{");
        var processed = new HashSet<string>();
        foreach (var t in rootTypes)
            GenerateForType(t, sb, processed, protoNs, compilation);
        sb.AppendLine("}");
        return sb.ToString();
    }

    static bool IsEnumType(ITypeSymbol type, Compilation compilation)
    {
        if (type.TypeKind == TypeKind.Enum)
            return true;
        if (type.TypeKind == TypeKind.Error)
        {
            var match = compilation.GetSymbolsWithName(type.Name, SymbolFilter.Type)
                .OfType<INamedTypeSymbol>()
                .FirstOrDefault(s => s.ToDisplayString() == type.ToDisplayString() && s.TypeKind == TypeKind.Enum);
            return match != null;
        }
        return false;
    }

    static void GenerateForType(ITypeSymbol type, StringBuilder sb, HashSet<string> processed, string protoNs, Compilation compilation)
    {
        if (type is null) return;
        if (IsEnumType(type, compilation)) { processed.Add(type.ToDisplayString()); return; }
        if (type is IArrayTypeSymbol arr) { GenerateForType(arr.ElementType, sb, processed, protoNs, compilation); return; }
        if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var keyType, out var valueType)) { if (keyType != null) GenerateForType(keyType, sb, processed, protoNs, compilation); if (valueType != null) GenerateForType(valueType, sb, processed, protoNs, compilation); return; }
        if (GeneratorHelpers.TryGetEnumerableElementType(type, out var elemType)) { if (elemType != null) GenerateForType(elemType, sb, processed, protoNs, compilation); return; }
        if (type is not INamedTypeSymbol named) return;
        var fullName = named.ToDisplayString();
        if (processed.Contains(fullName)) return;
        if (GeneratorHelpers.IsWellKnownType(named)) return;
        processed.Add(fullName);
        string stateName = named.Name + "State";
        sb.AppendLine($"    public static {protoNs}.{stateName} ToProto({fullName} model)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var state = new {protoNs}.{stateName}();");
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.GetMethod == null) continue;
            var propType = prop.Type;
            string propName = prop.Name;
            if (IsEnumType(propType, compilation))
                sb.AppendLine($"        state.{propName} = (int)model.{propName};");
            else if (GeneratorHelpers.IsWellKnownType(propType))
                sb.AppendLine($"        state.{propName} = model.{propName};");
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                string sel = string.Empty;
                if (elem != null)
                {
                    if (IsEnumType(elem, compilation))
                        sel = ".Select(e => (int)e)";
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                    {
                        GenerateForType(elem, sb, processed, protoNs, compilation);
                        sel = ".Select(ToProto)";
                    }
                }
                sb.AppendLine($"        if (model.{propName} != null) state.{propName}.Add(model.{propName}{sel});");
            }
            else
            {
                GenerateForType(propType, sb, processed, protoNs, compilation);
                sb.AppendLine($"        state.{propName} = ToProto(model.{propName});");
            }
        }
        sb.AppendLine("        return state;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static {fullName} FromProto({protoNs}.{stateName} state)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var model = new {fullName}();");
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.SetMethod == null) continue;
            var propType = prop.Type;
            string propName = prop.Name;
            if (IsEnumType(propType, compilation))
                sb.AppendLine($"        model.{propName} = ({propType.ToDisplayString()})state.{propName};");
            else if (GeneratorHelpers.IsWellKnownType(propType))
                sb.AppendLine($"        model.{propName} = state.{propName};");
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                string sel = string.Empty;
                if (elem != null)
                {
                    if (IsEnumType(elem, compilation))
                        sel = ".Select(e => (" + elem.ToDisplayString() + ")e)";
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                    {
                        GenerateForType(elem, sb, processed, protoNs, compilation);
                        sel = ".Select(FromProto)";
                    }
                }
                sb.AppendLine($"        model.{propName} = state.{propName}{sel}.ToList();");
            }
            else
            {
                GenerateForType(propType, sb, processed, protoNs, compilation);
                sb.AppendLine($"        model.{propName} = FromProto(state.{propName});");
            }
        }
        sb.AppendLine("        return model;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }
}
