using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GrpcRemoteMvvmModelUtil;

namespace RemoteMvvmTool.Generators;

public static class ConversionGenerator
{
    public static string Generate(string protoNs, string viewModelNs, IEnumerable<ITypeSymbol> rootTypes, Compilation compilation)
    {
        var body = new StringBuilder();
        var processed = new HashSet<string>();
        bool needsTimestamp = false;
        foreach (var t in rootTypes)
            GenerateForType(t, body, processed, protoNs, compilation, ref needsTimestamp);

        var sb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(sb);
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine($"using {protoNs};");
        if (needsTimestamp)
        {
            sb.AppendLine("using System;");
            sb.AppendLine("using Google.Protobuf.WellKnownTypes;");
        }
        sb.AppendLine();
        sb.AppendLine($"namespace {viewModelNs};");
        sb.AppendLine();
        sb.AppendLine("public static class ProtoStateConverters");
        sb.AppendLine("{");
        sb.Append(body);
        sb.AppendLine("}");
        return sb.ToString();
    }

    static bool IsEnumType(ITypeSymbol type, Compilation compilation)
    {
        if (type.TypeKind == TypeKind.Enum)
            return true;
        if (type.TypeKind == TypeKind.Error)
        {
            var match = compilation.GetSymbolsWithName(type.Name, SymbolFilter.Type)
                .OfType<INamedTypeSymbol>()
                .FirstOrDefault(s => s.ToDisplayString() == type.ToDisplayString() && s.TypeKind == TypeKind.Enum);
            return match != null;
        }
        return false;
    }

    static bool IsDateTime(ITypeSymbol type, out bool isNullable)
    {
        isNullable = false;
        if (type.SpecialType == SpecialType.System_DateTime) return true;
        if (type is INamedTypeSymbol named && named.IsGenericType &&
            named.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T &&
            named.TypeArguments.Length == 1 &&
            named.TypeArguments[0].SpecialType == SpecialType.System_DateTime)
        {
            isNullable = true;
            return true;
        }
        return false;
    }

    static void GenerateForType(ITypeSymbol type, StringBuilder sb, HashSet<string> processed, string protoNs, Compilation compilation, ref bool needsTimestamp)
    {
        if (type is null) return;
        if (IsEnumType(type, compilation)) { processed.Add(type.ToDisplayString()); return; }
        if (type is IArrayTypeSymbol arr) { GenerateForType(arr.ElementType, sb, processed, protoNs, compilation, ref needsTimestamp); return; }
        if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var keyType, out var valueType)) { if (keyType != null) GenerateForType(keyType, sb, processed, protoNs, compilation, ref needsTimestamp); if (valueType != null) GenerateForType(valueType, sb, processed, protoNs, compilation, ref needsTimestamp); return; }
        if (GeneratorHelpers.TryGetEnumerableElementType(type, out var elemType)) { if (elemType != null) GenerateForType(elemType, sb, processed, protoNs, compilation, ref needsTimestamp); return; }
        if (type is not INamedTypeSymbol named) return;
        var fullName = named.ToDisplayString();
        if (processed.Contains(fullName)) return;
        if (GeneratorHelpers.IsWellKnownType(named)) return;
        processed.Add(fullName);
        string stateName = named.Name + "State";
        sb.AppendLine($"    public static {protoNs}.{stateName} ToProto({fullName} model)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var state = new {protoNs}.{stateName}();");
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.GetMethod == null) continue;
            var propType = prop.Type;
            string propName = prop.Name;
            if (IsEnumType(propType, compilation))
                sb.AppendLine($"        state.{propName} = (int)model.{propName};");
            else if (IsDateTime(propType, out var propNullable))
            {
                needsTimestamp = true;
                if (propNullable)
                    sb.AppendLine($"        if (model.{propName} != null) state.{propName} = Timestamp.FromDateTime(model.{propName}.Value.ToUniversalTime());");
                else
                    sb.AppendLine($"        state.{propName} = Timestamp.FromDateTime(model.{propName}.ToUniversalTime());");
            }
            else if (GeneratorHelpers.IsWellKnownType(propType))
                sb.AppendLine($"        state.{propName} = model.{propName};");
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                string sel = string.Empty;
                if (elem != null)
                {
                    if (IsEnumType(elem, compilation))
                        sel = ".Select(e => (int)e)";
                    else if (IsDateTime(elem, out _))
                    {
                        needsTimestamp = true;
                        sel = ".Select(e => Timestamp.FromDateTime(e.ToUniversalTime()))";
                    }
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                    {
                        GenerateForType(elem, sb, processed, protoNs, compilation, ref needsTimestamp);
                        sel = ".Select(ToProto)";
                    }
                }
                sb.AppendLine($"        if (model.{propName} != null) state.{propName}.Add(model.{propName}{sel});");
            }
            else
            {
                GenerateForType(propType, sb, processed, protoNs, compilation, ref needsTimestamp);
                sb.AppendLine($"        state.{propName} = ToProto(model.{propName});");
            }
        }
        sb.AppendLine("        return state;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine($"    public static {fullName} FromProto({protoNs}.{stateName} state)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var model = new {fullName}();");
        foreach (var prop in Helpers.GetAllMembers(named).OfType<IPropertySymbol>())
        {
            if (prop.IsStatic) continue;
            if (prop.DeclaredAccessibility != Accessibility.Public || prop.SetMethod == null) continue;
            var propType = prop.Type;
            string propName = prop.Name;
            if (IsEnumType(propType, compilation))
                sb.AppendLine($"        model.{propName} = ({propType.ToDisplayString()})state.{propName};");
            else if (IsDateTime(propType, out var propNullable))
            {
                needsTimestamp = true;
                if (propNullable)
                    sb.AppendLine($"        model.{propName} = state.{propName}?.ToDateTime();");
                else
                    sb.AppendLine($"        model.{propName} = state.{propName}?.ToDateTime() ?? DateTime.MinValue;");
            }
            else if (GeneratorHelpers.IsWellKnownType(propType))
                sb.AppendLine($"        model.{propName} = state.{propName};");
            else if (GeneratorHelpers.TryGetEnumerableElementType(propType, out var elem))
            {
                string sel = string.Empty;
                if (elem != null)
                {
                    if (IsEnumType(elem, compilation))
                        sel = ".Select(e => (" + elem.ToDisplayString() + ")e)";
                    else if (IsDateTime(elem, out _))
                    {
                        needsTimestamp = true;
                        sel = ".Select(e => e.ToDateTime())";
                    }
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                    {
                        GenerateForType(elem, sb, processed, protoNs, compilation, ref needsTimestamp);
                        sel = ".Select(FromProto)";
                    }
                }
                sb.AppendLine($"        model.{propName} = state.{propName}{sel}.ToList();");
            }
            else
            {
                GenerateForType(propType, sb, processed, protoNs, compilation, ref needsTimestamp);
                sb.AppendLine($"        model.{propName} = FromProto(state.{propName});");
            }
        }
        sb.AppendLine("        return model;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }
}
