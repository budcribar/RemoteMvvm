using GrpcRemoteMvvmModelUtil;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RemoteMvvmTool.Generators;

/// <summary>
/// Generates C# client code for RemoteMvvm view models.
/// </summary>
public static class ClientGenerator
{
    /// <summary>
    /// Produces the source code for a remote client that communicates with a generated gRPC service.
    /// </summary>
    /// <param name="vmName">The name of the source view model.</param>
    /// <param name="protoNs">The namespace containing the generated protobuf types.</param>
    /// <param name="serviceName">The gRPC service name.</param>
    /// <param name="props">The observable properties exposed by the view model.</param>
    /// <param name="cmds">The commands exposed by the view model.</param>
    /// <param name="clientNamespace">Optional namespace for the generated client class.</param>
    /// <returns>The generated C# source code.</returns>
    public static string Generate(string vmName, string protoNs, string serviceName, List<PropertyInfo> props, List<CommandInfo> cmds, string? clientNamespace = null)
    {
        foreach (var p in props)
        {
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(p.FullTypeSymbol!);
            if (wkt == "Timestamp" || wkt == "Duration")
                throw new NotSupportedException($"Property '{p.Name}' with type '{p.TypeString}' is not supported by the client generator.");
        }
        foreach (var cmd in cmds)
        {
            foreach (var p in cmd.Parameters)
            {
                var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(p.FullTypeSymbol!);
                if (wkt == "Timestamp" || wkt == "Duration")
                    throw new NotSupportedException($"Parameter '{p.Name}' of command '{cmd.MethodName}' uses unsupported type '{p.TypeString}'.");
            }
        }
        int lastDot = protoNs.LastIndexOf('.');
        var ns = clientNamespace ?? (lastDot >= 0 ? $"{protoNs.Substring(0, lastDot)}.RemoteClients" : $"{protoNs}.RemoteClients");

        var headerSb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(headerSb);

        var template = GeneratorHelpers.LoadTemplate("RemoteMvvmTool.Resources.ClientTemplate.tmpl");

        var propertyDecls = new StringBuilder();
        foreach (var prop in props)
        {
            string backingFieldName = $"_{GeneratorHelpers.LowercaseFirst(prop.Name)}";
            propertyDecls.AppendLine($"        private {prop.TypeString} {backingFieldName} = default!;");
            propertyDecls.AppendLine($"        public {prop.TypeString} {prop.Name}");
            propertyDecls.AppendLine("        {");
            propertyDecls.AppendLine($"            get => {backingFieldName};");
            propertyDecls.AppendLine($"            private set => SetProperty(ref {backingFieldName}, value);");
            propertyDecls.AppendLine("        }");
            propertyDecls.AppendLine();
        }

        var commandDecls = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string commandInterfaceType = cmd.IsAsync ? "IAsyncRelayCommand" : "IRelayCommand";
            string methodGenericTypeArg = "";
            if (cmd.Parameters.Any())
            {
                string paramType = cmd.Parameters.Count == 1
                    ? cmd.Parameters[0].TypeString
                    : $"({string.Join(", ", cmd.Parameters.Select(p => p.TypeString))})";
                methodGenericTypeArg = $"<{paramType}>";
                commandInterfaceType = cmd.IsAsync ? $"IAsyncRelayCommand{methodGenericTypeArg}" : $"IRelayCommand{methodGenericTypeArg}";
            }
            commandDecls.AppendLine($"        public {commandInterfaceType} {cmd.CommandPropertyName} {{ get; }}");
        }
        commandDecls.AppendLine();

        var commandInits = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string baseName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            string remoteExecuteMethodName = $"RemoteExecute_{baseName}";
            string methodGenericTypeArg = "";
            string commandConcreteType = cmd.IsAsync ? "AsyncRelayCommand" : "RelayCommand";
            if (cmd.Parameters.Any())
            {
                string paramType = cmd.Parameters.Count == 1
                    ? cmd.Parameters[0].TypeString
                    : $"({string.Join(", ", cmd.Parameters.Select(p => p.TypeString))})";
                methodGenericTypeArg = $"<{paramType}>";
                commandConcreteType += methodGenericTypeArg;
            }
            if (cmd.IsAsync)
                commandInits.AppendLine($"            {cmd.CommandPropertyName} = new {commandConcreteType}({remoteExecuteMethodName}Async);");
            else
                commandInits.AppendLine($"            {cmd.CommandPropertyName} = new {commandConcreteType}({remoteExecuteMethodName});");
        }

        string KeyFromProto(string expr, ITypeSymbol type)
        {
            if (type.TypeKind == TypeKind.Enum || type.TypeKind == TypeKind.Error)
                return $"({type.ToDisplayString()}){expr}";
            return GeneratorHelpers.GetProtoWellKnownTypeFor(type) switch
            {
                "Int32Value" => type.SpecialType == SpecialType.System_Int32 ? expr : $"({type.ToDisplayString()}){expr}",
                "UInt32Value" => type.SpecialType == SpecialType.System_UInt32 ? expr : $"({type.ToDisplayString()}){expr}",
                "Int64Value" => expr,
                "UInt64Value" => expr,
                "StringValue" => type.ToDisplayString() == "System.Guid" ? $"Guid.Parse({expr})" : expr,
                _ => expr
            };
        }

        string ValueFromProto(string expr, ITypeSymbol type, string prefix)
        {
            if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var k, out var v))
                return DictFromProto(expr, k!, v!, prefix + "_kv");
            if (type.TypeKind == TypeKind.Enum) return $"({type.ToDisplayString()}){expr}";
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(type);
            if (wkt == "Timestamp") return $"{expr}.ToDateTime()";
            if (!GeneratorHelpers.IsWellKnownType(type)) return $"ProtoStateConverters.FromProto({expr})";
            return expr;
        }

        string DictFromProto(string fieldExpr, ITypeSymbol kType, ITypeSymbol vType, string _)
        {
            string keySel = KeyFromProto("k.Key", kType);
            string valSel = ValueFromProto("v.Value", vType, "v1");
            return $"{fieldExpr}.ToDictionary(k => {keySel}, v => {valSel})";
        }

        string BuildPropertyAssignments(int indent)
        {
            var psb = new StringBuilder();
            string ind = new string(' ', indent);
            foreach (var prop in props)
            {
                string protoStateFieldName = GeneratorHelpers.ToPascalCase(prop.Name);
                if (prop.FullTypeSymbol is INamedTypeSymbol named && named.IsGenericType)
                {
                    if (GeneratorHelpers.TryGetDictionaryTypeArgs(named, out _, out _))
                    {
                        var keyType = named.TypeArguments[0];
                        var valueType = named.TypeArguments[1];
                        var dictExpr = DictFromProto($"state.{protoStateFieldName}", keyType, valueType, "k");
                        if (named.TypeKind == TypeKind.Interface)
                            psb.AppendLine($"{ind}this.{prop.Name} = {dictExpr};");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}({dictExpr});");
                    }
                    else if (GeneratorHelpers.TryGetMemoryElementType(named, out var memElem))
                    {
                        if (memElem?.SpecialType == SpecialType.System_Byte)
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}.Memory;");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}.ToArray();");
                    }
                    else if (GeneratorHelpers.TryGetEnumerableElementType(named, out var elem))
                    {
                        string sel = string.Empty;
                        if (elem!.TypeKind == TypeKind.Enum)
                            sel = $".Select(e => ({elem.ToDisplayString()})e)";
                        else if (!GeneratorHelpers.IsWellKnownType(elem))
                            sel = ".Select(ProtoStateConverters.FromProto)";
                        if (named.TypeKind == TypeKind.Interface)
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}{sel}.ToList();");
                        else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                            psb.AppendLine($"{ind}this.{prop.Name} = new System.Collections.ObjectModel.ObservableCollection<{elem.ToDisplayString()}>(state.{protoStateFieldName}{sel});");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}(state.{protoStateFieldName}{sel});");
                    }
                    else
                    {
                        if (prop.FullTypeSymbol.TypeKind == TypeKind.Enum)
                            psb.AppendLine($"{ind}this.{prop.Name} = ({prop.TypeString})state.{protoStateFieldName};");
                        else if (!GeneratorHelpers.IsWellKnownType(prop.FullTypeSymbol))
                            psb.AppendLine($"{ind}this.{prop.Name} = ProtoStateConverters.FromProto(state.{protoStateFieldName});");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName};");
                    }
                }
                else if (prop.FullTypeSymbol is IArrayTypeSymbol arr)
                {
                    string sel = string.Empty;
                    var elem = arr.ElementType;
                    if (elem.TypeKind == TypeKind.Enum)
                        sel = $".Select(e => ({elem.ToDisplayString()})e)";
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                        sel = ".Select(ProtoStateConverters.FromProto)";
                    psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}{sel}.ToArray();");
                }
                else
                {
                    if (prop.FullTypeSymbol.TypeKind == TypeKind.Enum)
                        psb.AppendLine($"{ind}this.{prop.Name} = ({prop.TypeString})state.{protoStateFieldName};");
                    else if (!GeneratorHelpers.IsWellKnownType(prop.FullTypeSymbol))
                        psb.AppendLine($"{ind}this.{prop.Name} = ProtoStateConverters.FromProto(state.{protoStateFieldName});");
                    else
                        psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName};");
                }
            }
            return psb.ToString();
        }

        var assignmentsPing = BuildPropertyAssignments(32);
        var assignmentsInit = BuildPropertyAssignments(16);

        var commandMethods = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string cmdMethodNameForLog = cmd.MethodName;
            string baseMethodName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            string paramListWithType = string.Join(", ", cmd.Parameters.Select(p => $"{p.TypeString} {GeneratorHelpers.LowercaseFirst(p.Name)}"));
            string requestCreation = $"new {protoNs}.{cmd.MethodName}Request()";
            if (cmd.Parameters.Any())
            {
                var paramAssignments = cmd.Parameters.Select(p =>
                {
                    var varName = GeneratorHelpers.LowercaseFirst(p.Name);
                    string expr = p.FullTypeSymbol.TypeKind == TypeKind.Enum
                        ? $"(int){varName}"
                        : (!GeneratorHelpers.IsWellKnownType(p.FullTypeSymbol)
                            ? $"ProtoStateConverters.ToProto({varName})"
                            : varName);
                    return $"{GeneratorHelpers.ToPascalCase(p.Name)} = {expr}";
                });
                requestCreation = $"new {protoNs}.{cmd.MethodName}Request {{ {string.Join(", ", paramAssignments)} }}";
            }
            string methodSignature = cmd.IsAsync ? $"private async Task RemoteExecute_{baseMethodName}Async({paramListWithType})" : $"private void RemoteExecute_{baseMethodName}({paramListWithType})";
            commandMethods.AppendLine($"        {methodSignature}");
            commandMethods.AppendLine("        {");
            string earlyExit = "return;";
            commandMethods.AppendLine($"            if (!_isInitialized || _isDisposed) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Not initialized or disposed, command {cmdMethodNameForLog} skipped.\"); {earlyExit} }}");
            commandMethods.AppendLine($"            Debug.WriteLine(\"[ClientProxy:{vmName}] Executing command {cmdMethodNameForLog} remotely...\");");
            commandMethods.AppendLine("            try");
            commandMethods.AppendLine("            {");
            if (cmd.IsAsync)
                commandMethods.AppendLine($"                await _grpcClient.{cmd.MethodName}Async({requestCreation}, cancellationToken: _cts.Token);");
            else
                commandMethods.AppendLine($"                _ = _grpcClient.{cmd.MethodName}Async({requestCreation}, cancellationToken: _cts.Token);");
            commandMethods.AppendLine("            }");
            commandMethods.AppendLine($"            catch (RpcException ex) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Error executing command {cmdMethodNameForLog}: \" + ex.Status.StatusCode + \" - \" + ex.Status.Detail); }}");
            commandMethods.AppendLine($"            catch (OperationCanceledException) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Command {cmdMethodNameForLog} cancelled.\"); }}");
            commandMethods.AppendLine($"            catch (Exception ex) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Unexpected error executing command {cmdMethodNameForLog}: \" + ex.Message); }}");
            commandMethods.AppendLine("        }");
            commandMethods.AppendLine();
        }

        var propertyUpdateCases = new StringBuilder();
        foreach (var prop in props)
        {
            string wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(prop.FullTypeSymbol!);
            string csharpPropName = prop.Name;
            propertyUpdateCases.AppendLine($"                                   case nameof({csharpPropName}):");
            if (wkt == "StringValue")
                propertyUpdateCases.AppendLine($"                 if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<StringValue>().Value; break;");
            else if (wkt == "Int32Value")
                propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(Int32Value.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<Int32Value>().Value; break;");
            else if (wkt == "Int64Value")
                propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(Int64Value.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<Int64Value>().Value; break;");
            else if (wkt == "UInt32Value")
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(UInt32Value.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<UInt32Value>().Value; break;");
            else if (wkt == "DoubleValue")
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(DoubleValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<DoubleValue>().Value; break;");
            else if (wkt == "FloatValue")
                propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(FloatValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<FloatValue>().Value; break;");
            else if (wkt == "BoolValue")
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(BoolValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<BoolValue>().Value; break;");
            else
                propertyUpdateCases.AppendLine($"                                       Debug.WriteLine($\"[ClientProxy:{vmName}] Unpacking for {prop.Name} with WKT {wkt} not fully implemented or is Any.\"); break;");
        }

        var result = GeneratorHelpers.ReplacePlaceholders(template, new Dictionary<string, string>
        {
            ["<<AUTO_GENERATED_HEADER>>"] = headerSb.ToString().TrimEnd(),
            ["<<NAMESPACE>>"] = ns,
            ["<<VIEW_MODEL_NAME>>"] = vmName,
            ["<<PROTO_NS>>"] = protoNs,
            ["<<SERVICE_NAME>>"] = serviceName,
            ["<<PROPERTY_DECLARATIONS>>"] = propertyDecls.ToString(),
            ["<<COMMAND_DECLARATIONS>>"] = commandDecls.ToString(),
            ["<<COMMAND_INITIALIZATIONS>>"] = commandInits.ToString(),
            ["<<PROPERTY_ASSIGNMENTS_INIT>>"] = assignmentsInit,
            ["<<PROPERTY_ASSIGNMENTS_PING>>"] = assignmentsPing,
            ["<<COMMAND_METHODS>>"] = commandMethods.ToString(),
            ["<<PROPERTY_UPDATE_CASES>>"] = propertyUpdateCases.ToString(),
        });

        return result;
    }

}
