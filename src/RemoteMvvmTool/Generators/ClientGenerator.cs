using GrpcRemoteMvvmModelUtil;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RemoteMvvmTool.Generators;

/// <summary>
/// Generates C# client code for RemoteMvvm view models.
/// </summary>
public static class ClientGenerator
{
    /// <summary>
    /// Produces the source code for a remote client that communicates with a generated gRPC service.
    /// </summary>
    /// <param name="vmName">The name of the source view model.</param>
    /// <param name="protoNs">The namespace containing the generated protobuf types.</param>
    /// <param name="serviceName">The gRPC service name.</param>
    /// <param name="props">The observable properties exposed by the view model.</param>
    /// <param name="cmds">The commands exposed by the view model.</param>
    /// <param name="clientNamespace">Optional namespace for the generated client class.</param>
    /// <returns>The generated C# source code.</returns>
    public static string Generate(string vmName, string protoNs, string serviceName, List<PropertyInfo> props, List<CommandInfo> cmds, string? clientNamespace = null)
    {
        foreach (var p in props)
        {
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(p.FullTypeSymbol!);
            if (wkt == "Timestamp" || wkt == "Duration")
                throw new NotSupportedException($"Property '{p.Name}' with type '{p.TypeString}' is not supported by the client generator.");
        }
        foreach (var cmd in cmds)
        {
            foreach (var p in cmd.Parameters)
            {
                var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(p.FullTypeSymbol!);
                if (wkt == "Timestamp" || wkt == "Duration")
                    throw new NotSupportedException($"Parameter '{p.Name}' of command '{cmd.MethodName}' uses unsupported type '{p.TypeString}'.");
            }
        }
        int lastDot = protoNs.LastIndexOf('.');
        var ns = clientNamespace ?? (lastDot >= 0 ? $"{protoNs.Substring(0, lastDot)}.RemoteClients" : $"{protoNs}.RemoteClients");

        var headerSb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(headerSb);

        var template = GeneratorHelpers.LoadTemplate("RemoteMvvmTool.Resources.ClientTemplate.tmpl");

        var propertyDecls = new StringBuilder();
        foreach (var prop in props)
        {
            string backingFieldName = $"_{GeneratorHelpers.LowercaseFirst(prop.Name)}";
            propertyDecls.AppendLine($"        private {prop.TypeString} {backingFieldName} = default!;");
            propertyDecls.AppendLine($"        public {prop.TypeString} {prop.Name}");
            propertyDecls.AppendLine("        {");
            propertyDecls.AppendLine($"            get => {backingFieldName};");
            propertyDecls.AppendLine($"            private set => SetProperty(ref {backingFieldName}, value);");
            propertyDecls.AppendLine("        }");
            propertyDecls.AppendLine();
        }

        var commandDecls = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string commandInterfaceType = cmd.IsAsync ? "IAsyncRelayCommand" : "IRelayCommand";
            string methodGenericTypeArg = "";
            if (cmd.Parameters.Any())
            {
                string paramType = cmd.Parameters.Count == 1
                    ? cmd.Parameters[0].TypeString
                    : $"({string.Join(", ", cmd.Parameters.Select(p => p.TypeString))})";
                methodGenericTypeArg = $"<{paramType}>";
                commandInterfaceType = cmd.IsAsync ? $"IAsyncRelayCommand{methodGenericTypeArg}" : $"IRelayCommand{methodGenericTypeArg}";
            }
            commandDecls.AppendLine($"        public {commandInterfaceType} {cmd.CommandPropertyName} {{ get; }}");
        }
        commandDecls.AppendLine();

        var commandInits = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string baseName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            string remoteExecuteMethodName = $"RemoteExecute_{baseName}";
            string methodGenericTypeArg = "";
            string commandConcreteType = cmd.IsAsync ? "AsyncRelayCommand" : "RelayCommand";
            if (cmd.Parameters.Any())
            {
                string paramType = cmd.Parameters.Count == 1
                    ? cmd.Parameters[0].TypeString
                    : $"({string.Join(", ", cmd.Parameters.Select(p => p.TypeString))})";
                methodGenericTypeArg = $"<{paramType}>";
                commandConcreteType += methodGenericTypeArg;
            }
            if (cmd.IsAsync)
                commandInits.AppendLine($"            {cmd.CommandPropertyName} = new {commandConcreteType}({remoteExecuteMethodName}Async);");
            else
                commandInits.AppendLine($"            {cmd.CommandPropertyName} = new {commandConcreteType}({remoteExecuteMethodName});");
        }

        string KeyFromProto(string expr, ITypeSymbol type)
        {
            if (type.TypeKind == TypeKind.Enum || type.TypeKind == TypeKind.Error)
                return $"({type.ToDisplayString()}){expr}";
            return GeneratorHelpers.GetProtoWellKnownTypeFor(type) switch
            {
                "Int32Value" => type.SpecialType == SpecialType.System_Int32 ? expr : $"({type.ToDisplayString()}){expr}",
                "UInt32Value" => type.SpecialType == SpecialType.System_UInt32 ? expr : $"({type.ToDisplayString()}){expr}",
                "Int64Value" => type.SpecialType == SpecialType.System_Int64 ? expr : $"({type.ToDisplayString()}){expr}",
                "UInt64Value" => type.SpecialType == SpecialType.System_UInt64 ? expr : $"({type.ToDisplayString()}){expr}",
                "StringValue" => type.ToDisplayString() switch
                {
                    "System.Guid" => $"Guid.Parse({expr})",
                    "System.Char" or "char" => $"{expr}[0]",
                    "System.Decimal" or "decimal" => $"decimal.Parse({expr})",
                    "System.DateOnly" => $"DateOnly.Parse({expr})",
                    "System.TimeOnly" => $"TimeOnly.Parse({expr})",
                    "System.Half" => $"(Half)float.Parse({expr})",
                    _ => expr
                },
                "FloatValue" => type.ToDisplayString() == "System.Half" ? $"(Half){expr}" : expr,
                _ => expr
            };
        }

        string ValueFromProto(string expr, ITypeSymbol type, string prefix)
        {
            if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var k, out var v))
                return DictFromProto(expr, k!, v!, prefix + "_kv");
            if (type.TypeKind == TypeKind.Enum) return $"({type.ToDisplayString()}){expr}";
            
            // Handle collection types (List<T>, IEnumerable<T>, etc.)
            if (GeneratorHelpers.TryGetEnumerableElementType(type, out var elemType) && type.SpecialType != SpecialType.System_String)
            {
                // Convert RepeatedField<T> to the target collection type
                string elemConversion = elemType!.TypeKind == TypeKind.Enum 
                    ? $".Select(e => ({elemType.ToDisplayString()})e)" 
                    : (!GeneratorHelpers.IsWellKnownType(elemType) 
                        ? ".Select(ProtoStateConverters.FromProto)" 
                        : "");
                        
                if (type is INamedTypeSymbol named)
                {
                    if (named.TypeKind == TypeKind.Interface)
                        return $"{expr}{elemConversion}.ToList()";
                    else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                        return $"new System.Collections.ObjectModel.ObservableCollection<{elemType.ToDisplayString()}>({expr}{elemConversion})";
                    else
                        return $"new {type.ToDisplayString()}({expr}{elemConversion})";
                }
                else
                {
                    return $"{expr}{elemConversion}.ToList()";
                }
            }
            
            // Handle array types
            if (type is IArrayTypeSymbol arrType)
            {
                var elem = arrType.ElementType;
                string elemConversion = elem.TypeKind == TypeKind.Enum 
                    ? $".Select(e => ({elem.ToDisplayString()})e)" 
                    : (!GeneratorHelpers.IsWellKnownType(elem) 
                        ? ".Select(ProtoStateConverters.FromProto)" 
                        : "");
                return $"{expr}{elemConversion}.ToArray()";
            }
            
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(type);
            if (wkt == "Timestamp") return $"{expr}.ToDateTime()";
            if (!GeneratorHelpers.IsWellKnownType(type)) return $"ProtoStateConverters.FromProto({expr})";
            return expr;
        }

        string DictFromProto(string fieldExpr, ITypeSymbol kType, ITypeSymbol vType, string _)
        {
            string keySel = KeyFromProto("k.Key", kType);
            string valSel = ValueFromProto("v.Value", vType, "v1");
            return $"{fieldExpr}.ToDictionary(k => {keySel}, v => {valSel})";
        }

        string BuildPropertyAssignments(int indent)
        {
            var psb = new StringBuilder();
            string ind = new string(' ', indent);
            foreach (var prop in props)
            {
                string protoStateFieldName = GeneratorHelpers.ToPascalCase(prop.Name);
                if (prop.FullTypeSymbol is INamedTypeSymbol named && named.IsGenericType)
                {
                    if (GeneratorHelpers.TryGetDictionaryTypeArgs(named, out _, out _))
                    {
                        var keyType = named.TypeArguments[0];
                        var valueType = named.TypeArguments[1];
                        var dictExpr = DictFromProto($"state.{protoStateFieldName}", keyType, valueType, "k");
                        if (named.TypeKind == TypeKind.Interface)
                            psb.AppendLine($"{ind}this.{prop.Name} = {dictExpr};");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}({dictExpr});");
                    }
                    else if (GeneratorHelpers.TryGetMemoryElementType(named, out var memElem))
                    {
                        if (memElem?.SpecialType == SpecialType.System_Byte)
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}.Memory;");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}.ToArray();");
                    }
                    else if (GeneratorHelpers.TryGetEnumerableElementType(named, out var elem))
                    {
                        // Special handling for collections of dictionaries
                        if (elem is INamedTypeSymbol elemNamed && elemNamed.IsGenericType &&
                            GeneratorHelpers.TryGetDictionaryTypeArgs(elemNamed, out var elemKeyType, out var elemValueType) &&
                            GeneratorHelpers.CanUseProtoMap(elemKeyType!, elemValueType!))
                        {
                            // This is a collection of dictionaries - convert from map-containing messages
                            string keySel = KeyFromProto("kv.Key", elemKeyType!);
                            string valSel = ValueFromProto("kv.Value", elemValueType!, "kv1");
                            string dictType = $"Dictionary<{elemKeyType!.ToDisplayString()}, {elemValueType!.ToDisplayString()}>";
                            string conversionExpr = $"state.{protoStateFieldName}.Select(mapMsg => mapMsg.Entries.ToDictionary(kv => {keySel}, kv => {valSel}))";
                            
                            if (named.TypeKind == TypeKind.Interface)
                                psb.AppendLine($"{ind}this.{prop.Name} = {conversionExpr}.ToList();");
                            else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                                psb.AppendLine($"{ind}this.{prop.Name} = new System.Collections.ObjectModel.ObservableCollection<{dictType}>({conversionExpr});");
                            else
                                psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}({conversionExpr});");
                        }
                        else
                        {
                            // Regular collection handling
                            string sel = string.Empty;
                            if (elem!.TypeKind == TypeKind.Enum)
                                sel = $".Select(e => ({elem.ToDisplayString()})e)";
                            else if (!GeneratorHelpers.IsWellKnownType(elem))
                                sel = ".Select(ProtoStateConverters.FromProto)";
                            
                            if (named.TypeKind == TypeKind.Interface)
                                psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}{sel}.ToList();");
                            else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                                psb.AppendLine($"{ind}this.{prop.Name} = new System.Collections.ObjectModel.ObservableCollection<{elem.ToDisplayString()}>(state.{protoStateFieldName}{sel});");
                            else
                                psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}(state.{protoStateFieldName}{sel});");
                        }
                    }
                    else
                    {
                        if (prop.FullTypeSymbol.TypeKind == TypeKind.Enum)
                            psb.AppendLine($"{ind}this.{prop.Name} = ({prop.TypeString})state.{protoStateFieldName};");
                        else if (!GeneratorHelpers.IsWellKnownType(prop.FullTypeSymbol))
                            psb.AppendLine($"{ind}this.{prop.Name} = ProtoStateConverters.FromProto(state.{protoStateFieldName});");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName};");
                    }
                }
                else if (prop.FullTypeSymbol is IArrayTypeSymbol arr)
                {
                    string sel = string.Empty;
                    var elem = arr.ElementType;
                    if (elem.TypeKind == TypeKind.Enum)
                        sel = $".Select(e => ({elem.ToDisplayString()})e)";
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                        sel = ".Select(ProtoStateConverters.FromProto)";
                    psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}{sel}.ToArray();");
                }
                else
                {
                    if (prop.FullTypeSymbol.TypeKind == TypeKind.Enum)
                        psb.AppendLine($"{ind}this.{prop.Name} = ({prop.TypeString})state.{protoStateFieldName};");
                    else if (!GeneratorHelpers.IsWellKnownType(prop.FullTypeSymbol))
                        psb.AppendLine($"{ind}this.{prop.Name} = ProtoStateConverters.FromProto(state.{protoStateFieldName});");
                    else
                    {
                        // Handle special type conversions for well-known types that need parsing
                        var typeDisplayString = prop.FullTypeSymbol.ToDisplayString();
                        var assignment = typeDisplayString switch
                        {
                            "System.Decimal" or "decimal" => $"decimal.Parse(state.{protoStateFieldName})",
                            "System.Char" or "char" => $"state.{protoStateFieldName}[0]",
                            "System.Guid" => $"Guid.Parse(state.{protoStateFieldName})",
                            "System.DateOnly" => $"DateOnly.Parse(state.{protoStateFieldName})",
                            "System.TimeOnly" => $"TimeOnly.Parse(state.{protoStateFieldName})",
                            "System.Half" => $"(Half)state.{protoStateFieldName}",
                            "nuint" or "System.UIntPtr" => $"(nuint)state.{protoStateFieldName}",
                            "short" or "System.Int16" => $"(short)state.{protoStateFieldName}",
                            "byte" or "System.Byte" => $"(byte)state.{protoStateFieldName}",
                            _ => $"state.{protoStateFieldName}"
                        };

                        if (prop.FullTypeSymbol.TypeKind == TypeKind.Enum)
                            psb.AppendLine($"{ind}this.{prop.Name} = ({prop.TypeString})state.{protoStateFieldName};");
                        else if (!GeneratorHelpers.IsWellKnownType(prop.FullTypeSymbol))
                            psb.AppendLine($"{ind}this.{prop.Name} = ProtoStateConverters.FromProto(state.{protoStateFieldName});");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = {assignment};");
                    }
                }
            }
            return psb.ToString();
        }

        var assignmentsPing = BuildPropertyAssignments(32);
        var assignmentsInit = BuildPropertyAssignments(16);

        var commandMethods = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string cmdMethodNameForLog = cmd.MethodName;
            string baseMethodName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            string paramListWithType = string.Join(", ", cmd.Parameters.Select(p => $"{p.TypeString} {GeneratorHelpers.LowercaseFirst(p.Name)}"));
            string requestCreation = $"new {protoNs}.{baseMethodName}Request()";
            if (cmd.Parameters.Any())
            {
                var paramAssignments = cmd.Parameters.Select(p =>
                {
                    var varName = GeneratorHelpers.LowercaseFirst(p.Name);
                    string expr = p.FullTypeSymbol.TypeKind == TypeKind.Enum
                        ? $"(int){varName}"
                        : (!GeneratorHelpers.IsWellKnownType(p.FullTypeSymbol)
                            ? $"ProtoStateConverters.ToProto({varName})"
                            : varName);
                    return $"{GeneratorHelpers.ToPascalCase(p.Name)} = {expr}";
                });
                requestCreation = $"new {protoNs}.{baseMethodName}Request {{ {string.Join(", ", paramAssignments)} }}";
            }
            string methodSignature = cmd.IsAsync ? $"private async Task RemoteExecute_{baseMethodName}Async({paramListWithType})" : $"private void RemoteExecute_{baseMethodName}({paramListWithType})";
            commandMethods.AppendLine($"        {methodSignature}");
            commandMethods.AppendLine("        {");
            string earlyExit = "return;";
            commandMethods.AppendLine($"            if (!_isInitialized || _isDisposed) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Not initialized or disposed, command {cmdMethodNameForLog} skipped.\"); {earlyExit} }}");
            commandMethods.AppendLine($"            Debug.WriteLine(\"[ClientProxy:{vmName}] Executing command {cmdMethodNameForLog} remotely...\");");
            commandMethods.AppendLine("            try");
            commandMethods.AppendLine("            {");
            var grpcMethod = baseMethodName + "Async";
            if (cmd.IsAsync)
                commandMethods.AppendLine($"                await _grpcClient.{grpcMethod}({requestCreation}, cancellationToken: _cts.Token);");
            else
                commandMethods.AppendLine($"                _ = _grpcClient.{grpcMethod}({requestCreation}, cancellationToken: _cts.Token);");
            commandMethods.AppendLine("            }");
            commandMethods.AppendLine($"            catch (RpcException ex) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Error executing command {cmdMethodNameForLog}: \" + ex.Status.StatusCode + \" - \" + ex.Status.Detail); }}");
            commandMethods.AppendLine($"            catch (OperationCanceledException) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Command {cmdMethodNameForLog} cancelled.\"); }}");
            commandMethods.AppendLine($"            catch (Exception ex) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Unexpected error executing command {cmdMethodNameForLog}: \" + ex.Message); }}");
            commandMethods.AppendLine("        }");
            commandMethods.AppendLine();
        }

        var propertyUpdateCases = new StringBuilder();
        foreach (var prop in props)
        {
            string wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(prop.FullTypeSymbol!);
            string csharpPropName = prop.Name;
            propertyUpdateCases.AppendLine($"                                   case nameof({csharpPropName}):");
            if (wkt == "StringValue")
            {
                var typeDisplayString = prop.FullTypeSymbol.ToDisplayString();
                switch (typeDisplayString)
                {
                    case "System.Decimal" or "decimal":
                        propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = decimal.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    case "System.Char" or "char":
                        propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<StringValue>().Value[0]; break;");
                        break;
                    case "System.Guid":
                        propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = Guid.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    case "System.DateOnly":
                        propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = DateOnly.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    case "System.TimeOnly":
                        propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = TimeOnly.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    default:
                        propertyUpdateCases.AppendLine($"                 if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<StringValue>().Value; break;");
                        break;
                }
            }
            else if (wkt == "Int32Value")
            {
                bool needsCast = prop.FullTypeSymbol.SpecialType != SpecialType.System_Int32;
                string cast = needsCast ? $"({prop.TypeString})" : string.Empty;
                propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(Int32Value.Descriptor)) this.{csharpPropName} = {cast}update.NewValue.Unpack<Int32Value>().Value; break;");
            }
            else if (wkt == "Int64Value")
            {
                bool needsCast = prop.FullTypeSymbol.SpecialType != SpecialType.System_Int64;
                string cast = needsCast ? $"({prop.TypeString})" : string.Empty;
                propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(Int64Value.Descriptor)) this.{csharpPropName} = {cast}update.NewValue.Unpack<Int64Value>().Value; break;");
            }
            else if (wkt == "UInt32Value")
            {
                bool needsCast = prop.FullTypeSymbol.SpecialType != SpecialType.System_UInt32;
                string cast = needsCast ? $"({prop.TypeString})" : string.Empty;
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(UInt32Value.Descriptor)) this.{csharpPropName} = {cast}update.NewValue.Unpack<UInt32Value>().Value; break;");
            }
            else if (wkt == "UInt64Value")
            {
                bool needsCast = prop.FullTypeSymbol.SpecialType != SpecialType.System_UInt64;
                string cast = needsCast ? $"({prop.TypeString})" : string.Empty;
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(UInt64Value.Descriptor)) this.{csharpPropName} = {cast}update.NewValue.Unpack<UInt64Value>().Value; break;");
            }
            else if (wkt == "DoubleValue")
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(DoubleValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<DoubleValue>().Value; break;");
            else if (wkt == "FloatValue")
            {
                var typeDisplayString = prop.FullTypeSymbol.ToDisplayString();
                if (typeDisplayString == "System.Half")
                    propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(FloatValue.Descriptor)) this.{csharpPropName} = (Half)update.NewValue.Unpack<FloatValue>().Value; break;");
                else
                    propertyUpdateCases.AppendLine($"                     if (update.NewValue!.Is(FloatValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<FloatValue>().Value; break;");
            }
            else if (wkt == "BoolValue")
                propertyUpdateCases.AppendLine($"                    if (update.NewValue!.Is(BoolValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<BoolValue>().Value; break;");
            else
                propertyUpdateCases.AppendLine($"                                       Debug.WriteLine($\"[ClientProxy:{vmName}] Unpacking for {prop.Name} with WKT {wkt} not fully implemented or is Any.\"); break;");
        }

        var result = GeneratorHelpers.ReplacePlaceholders(template, new Dictionary<string, string>
        {
            ["<<AUTO_GENERATED_HEADER>>"] = headerSb.ToString().TrimEnd(),
            ["<<NAMESPACE>>"] = ns,
            ["<<VIEW_MODEL_NAME>>"] = vmName,
            ["<<PROTO_NS>>"] = protoNs,
            ["<<SERVICE_NAME>>"] = serviceName,
            ["<<PROPERTY_DECLARATIONS>>"] = propertyDecls.ToString(),
            ["<<COMMAND_DECLARATIONS>>"] = commandDecls.ToString(),
            ["<<COMMAND_INITIALIZATIONS>>"] = commandInits.ToString(),
            ["<<PROPERTY_ASSIGNMENTS_INIT>>"] = assignmentsInit,
            ["<<PROPERTY_ASSIGNMENTS_PING>>"] = assignmentsPing,
            ["<<COMMAND_METHODS>>"] = commandMethods.ToString(),
            ["<<PROPERTY_UPDATE_CASES>>"] = propertyUpdateCases.ToString(),
        });

        return result;
    }

}
