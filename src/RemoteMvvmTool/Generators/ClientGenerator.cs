using GrpcRemoteMvvmModelUtil;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RemoteMvvmTool.Generators;

/// <summary>
/// Generates C# client code for RemoteMvvm view models.
/// </summary>
public static class ClientGenerator
{
    /// <summary>
    /// Produces the source code for a remote client that communicates with a generated gRPC service.
    /// </summary>
    /// <param name="vmName">The name of the source view model.</param>
    /// <param name="protoNs">The namespace containing the generated protobuf types.</param>
    /// <param name="serviceName">The gRPC service name.</param>
    /// <param name="props">The observable properties exposed by the view model.</param>
    /// <param name="cmds">The commands exposed by the view model.</param>
    /// <param name="clientNamespace">Optional namespace for the generated client class.</param>
    /// <param name="vmNamespace">The namespace of the view model.</param>
    /// <returns>The generated C# source code.</returns>
    public static string Generate(string vmName, string protoNs, string serviceName, List<PropertyInfo> props, List<CommandInfo> cmds, string? clientNamespace = null, string? vmNamespace = null)
    {
        // Previously, Timestamp/Duration were rejected. We now support them.
        // Keep early validation for future unsupported types if needed, but allow Timestamp/Duration.
        foreach (var p in props)
        {
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(p.FullTypeSymbol!);
            if (wkt == "Unknown")
            {
                // Unknown types should still be convertible via ProtoStateConverters.
            }
        }
        foreach (var cmd in cmds)
        {
            foreach (var p in cmd.Parameters)
            {
                var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(p.FullTypeSymbol!);
                if (wkt == "Unknown")
                {
                    // Unknown types should still be convertible via ProtoStateConverters.
                }
            }
        }
        int lastDot = protoNs.LastIndexOf('.');
        var ns = clientNamespace ?? (lastDot >= 0 ? $"{protoNs.Substring(0, lastDot)}.RemoteClients" : $"{protoNs}.RemoteClients");

        var headerSb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(headerSb);

        var template = GeneratorHelpers.LoadTemplate("RemoteMvvmTool.Resources.ClientTemplate.tmpl");

        var propertyDecls = new StringBuilder();
        foreach (var prop in props)
        {
            string backingFieldName = $"_{GeneratorHelpers.LowercaseFirst(prop.Name)}";
            propertyDecls.AppendLine($"        private {prop.TypeString} {backingFieldName} = default!;");
            propertyDecls.AppendLine($"        public {prop.TypeString} {prop.Name}");
            propertyDecls.AppendLine("        {");
            propertyDecls.AppendLine($"            get => {backingFieldName};");
            propertyDecls.AppendLine($"            private set => SetProperty(ref {backingFieldName}, value);");
            propertyDecls.AppendLine("        }");
            propertyDecls.AppendLine();
        }

        var commandDecls = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string commandInterfaceType = cmd.IsAsync ? "IAsyncRelayCommand" : "IRelayCommand";
            string methodGenericTypeArg = "";
            if (cmd.Parameters.Any())
            {
                string paramType = cmd.Parameters.Count == 1
                    ? cmd.Parameters[0].TypeString
                    : $"({string.Join(", ", cmd.Parameters.Select(p => p.TypeString))})";
                methodGenericTypeArg = $"<{paramType}>";
                commandInterfaceType = cmd.IsAsync ? $"IAsyncRelayCommand{methodGenericTypeArg}" : $"IRelayCommand{methodGenericTypeArg}";
            }
            commandDecls.AppendLine($"        public {commandInterfaceType} {cmd.CommandPropertyName} {{ get; }}");
        }
        commandDecls.AppendLine();

        var commandInits = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string baseName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            string remoteExecuteMethodName = $"RemoteExecute_{baseName}";
            string methodGenericTypeArg = "";
            string commandConcreteType = cmd.IsAsync ? "AsyncRelayCommand" : "RelayCommand";
            if (cmd.Parameters.Any())
            {
                string paramType = cmd.Parameters.Count == 1
                    ? cmd.Parameters[0].TypeString
                    : $"({string.Join(", ", cmd.Parameters.Select(p => p.TypeString))})";
                methodGenericTypeArg = $"<{paramType}>";
                commandConcreteType += methodGenericTypeArg;
            }
            if (cmd.IsAsync)
                commandInits.AppendLine($"            {cmd.CommandPropertyName} = new {commandConcreteType}({remoteExecuteMethodName}Async);");
            else
                commandInits.AppendLine($"            {cmd.CommandPropertyName} = new {commandConcreteType}({remoteExecuteMethodName});");
        }

        string KeyFromProto(string expr, ITypeSymbol type)
        {
            if (type.TypeKind == TypeKind.Enum || type.TypeKind == TypeKind.Error)
                return $"({type.ToDisplayString()}){expr}";
            return GeneratorHelpers.GetProtoWellKnownTypeFor(type) switch
            {
                "Int32Value" => type.SpecialType == SpecialType.System_Int32 ? expr : $"({type.ToDisplayString()}){expr}",
                "UInt32Value" => type.SpecialType == SpecialType.System_UInt32 ? expr : $"({type.ToDisplayString()}){expr}",
                "Int64Value" => type.SpecialType == SpecialType.System_Int64 ? expr : $"({type.ToDisplayString()}){expr}",
                "UInt64Value" => type.SpecialType == SpecialType.System_UInt64 ? expr : $"({type.ToDisplayString()}){expr}",
                "StringValue" => type.ToDisplayString() switch
                {
                    "System.Guid" => $"Guid.Parse({expr})",
                    "System.Char" or "char" => $"{expr}[0]",
                    "System.Decimal" or "decimal" => $"decimal.Parse({expr})",
                    "System.DateOnly" => $"DateOnly.Parse({expr})",
                    "System.TimeOnly" => $"TimeOnly.Parse({expr})",
                    "System.Half" => $"(Half)float.Parse({expr})",
                    _ => expr
                },
                "FloatValue" => type.ToDisplayString() == "System.Half" ? $"(Half){expr}" : expr,
                _ => expr
            };
        }

        string ValueToProto(string expr, ITypeSymbol type)
        {
            if (type.TypeKind == TypeKind.Enum) return $"(int){expr}";
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(type);
            if (wkt == "Timestamp") return $"Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime({expr}.ToUniversalTime())";
            if (wkt == "Duration") return $"Google.Protobuf.WellKnownTypes.Duration.FromTimeSpan({expr})";
            if (!GeneratorHelpers.IsWellKnownType(type)) return $"ProtoStateConverters.ToProto({expr})";
            var typeDisplayString = type.ToDisplayString();
            return typeDisplayString switch
            {
                "System.Half" => $"(float){expr}",
                "System.Char" or "char" => $"{expr}.ToString()",
                "System.Guid" => $"{expr}.ToString()",
                "System.Decimal" or "decimal" => $"{expr}.ToString()",
                "System.DateOnly" => $"{expr}.ToString()",
                "System.TimeOnly" => $"{expr}.ToString()",
                "nuint" or "System.UIntPtr" => $"(ulong){expr}",
                "nint" or "System.IntPtr" => $"(long){expr}",
                _ => expr
            };
        }

        bool DerivesFromObservableCollection(INamedTypeSymbol? t)
        {
            for (var bt = t?.BaseType; bt != null; bt = bt.BaseType)
                if (bt.OriginalDefinition.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                    return true;
            return false;
        }

        string ValueFromProto(string expr, ITypeSymbol type, string prefix)
        {
            if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var k, out var v))
                return DictFromProto(expr, k!, v!, prefix + "_kv");
            if (type.TypeKind == TypeKind.Enum) return $"({type.ToDisplayString()}){expr}";
            
            // Handle collection types (List<T>, IEnumerable<T>, etc.)
            if (GeneratorHelpers.TryGetEnumerableElementType(type, out var elemType) && type.SpecialType != SpecialType.System_String)
            {
                // Convert RepeatedField<T> to the target collection type
                string elemConversion = elemType!.TypeKind == TypeKind.Enum 
                    ? $".Select(e => ({elemType.ToDisplayString()})e)" 
                    : (!GeneratorHelpers.IsWellKnownType(elemType) 
                        ? ".Select(ProtoStateConverters.FromProto)" 
                        : "");
                        
                if (type is INamedTypeSymbol named)
                {
                    if (named.TypeKind == TypeKind.Interface)
                        return $"{expr}{elemConversion}.ToList()";
                    else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                        return $"new System.Collections.ObjectModel.ObservableCollection<{elemType.ToDisplayString()}>({expr}{elemConversion})";
                    else if (DerivesFromObservableCollection(named))
                        return $"{expr}{elemConversion}.Aggregate(new {type.ToDisplayString()}(), (c, e) => {{ c.Add(e); return c; }})";
                    else
                        return $"new {type.ToDisplayString()}({expr}{elemConversion})";
                }
                else
                {
                    return $"{expr}{elemConversion}.ToList()";
                }
            }
            
            // Handle array types
            if (type is IArrayTypeSymbol arrType)
            {
                var elem = arrType.ElementType;
                string elemConversion = elem.TypeKind == TypeKind.Enum 
                    ? $".Select(e => ({elem.ToDisplayString()})e)" 
                    : (!GeneratorHelpers.IsWellKnownType(elem) 
                        ? ".Select(ProtoStateConverters.FromProto)" 
                        : "");
                return $"{expr}{elemConversion}.ToArray()";
            }
            
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(type);
            if (wkt == "Timestamp") return $"{expr}.ToDateTime()";
            if (wkt == "Duration") return $"{expr}.ToTimeSpan()";
            if (!GeneratorHelpers.IsWellKnownType(type)) return $"ProtoStateConverters.FromProto({expr})";
            var typeDisplayString = type.ToDisplayString();
            return typeDisplayString switch
            {
                "System.Decimal" or "decimal" => $"decimal.Parse({expr})",
                "System.Char" or "char" => $"{expr}[0]",
                "System.Guid" => $"Guid.Parse({expr})",
                "System.DateOnly" => $"DateOnly.Parse({expr})",
                "System.TimeOnly" => $"TimeOnly.Parse({expr})",
                "System.Half" => $"(Half){expr}",
                "nuint" or "System.UIntPtr" => $"(nuint){expr}",
                "nint" or "System.IntPtr" => $"(nint){expr}",
                "short" or "System.Int16" => $"(short){expr}",
                "ushort" or "System.UInt16" => $"(ushort){expr}",
                "sbyte" or "System.SByte" => $"(sbyte){expr}",
                "byte" or "System.Byte" => $"(byte){expr}",
                _ => expr
            };
        }

        string DictFromProto(string fieldExpr, ITypeSymbol kType, ITypeSymbol vType, string _)
        {
            string keySel = KeyFromProto("k.Key", kType);
            string valSel = ValueFromProto("v.Value", vType, "v1");
            return $"{fieldExpr}.ToDictionary(k => {keySel}, v => {valSel})";
        }

        string BuildPropertyAssignments(int indent)
        {
            var psb = new StringBuilder();
            string ind = new string(' ', indent);
            foreach (var prop in props)
            {
                string protoStateFieldName = GeneratorHelpers.ToPascalCase(prop.Name);
                if (prop.FullTypeSymbol is INamedTypeSymbol named)
                {
                    if (named.IsGenericType && GeneratorHelpers.TryGetDictionaryTypeArgs(named, out _, out _))
                    {
                        var keyType = named.TypeArguments[0];
                        var valueType = named.TypeArguments[1];
                        var dictExpr = DictFromProto($"state.{protoStateFieldName}", keyType, valueType, "k");
                        if (named.TypeKind == TypeKind.Interface)
                            psb.AppendLine($"{ind}this.{prop.Name} = {dictExpr};");
                        else
                            psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}({dictExpr});");
                    }
                    else if (named.IsGenericType && GeneratorHelpers.TryGetMemoryElementType(named, out var memElem))
                    {
                        var typeDisplayString = named.ToDisplayString();
                        if (memElem?.SpecialType == SpecialType.System_Byte)
                        {
                            // Handle byte memory types
                            if (typeDisplayString.StartsWith("System.ReadOnlyMemory<"))
                                psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}.Memory;");
                            else // Memory<byte>
                                psb.AppendLine($"{ind}this.{prop.Name} = new Memory<byte>(state.{protoStateFieldName}.ToByteArray());");
                        }
                        else
                        {
                            // Handle non-byte memory types 
                            if (typeDisplayString.StartsWith("System.ReadOnlyMemory<"))
                                psb.AppendLine($"{ind}this.{prop.Name} = new ReadOnlyMemory<{memElem?.ToDisplayString()}>(state.{protoStateFieldName}.ToArray());");
                            else // Memory<T>
                                psb.AppendLine($"{ind}this.{prop.Name} = new Memory<{memElem?.ToDisplayString()}>(state.{protoStateFieldName}.ToArray());");
                        }
                    }
                    else if (GeneratorHelpers.TryGetEnumerableElementType(named, out var elem) && elem != null)
                    {
                        // Special handling for collections of dictionaries
                        if (elem is INamedTypeSymbol elemNamed && elemNamed.IsGenericType &&
                            GeneratorHelpers.TryGetDictionaryTypeArgs(elemNamed, out var elemKeyType, out var elemValueType) &&
                            elemKeyType != null && elemValueType != null &&
                            GeneratorHelpers.CanUseProtoMap(elemKeyType, elemValueType))
                        {
                            // This is a collection of dictionaries - convert from map-containing messages
                            string keySel = KeyFromProto("kv.Key", elemKeyType);
                            string valSel = ValueFromProto("kv.Value", elemValueType, "kv1");
                            string dictType = $"Dictionary<{elemKeyType.ToDisplayString()}, {elemValueType.ToDisplayString()}>";
                            string conversionExpr = $"state.{protoStateFieldName}.Select(mapMsg => mapMsg.Entries.ToDictionary(kv => {keySel}, kv => {valSel}))";

                            if (named.TypeKind == TypeKind.Interface)
                                psb.AppendLine($"{ind}this.{prop.Name} = {conversionExpr}.ToList();");
                            else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                                psb.AppendLine($"{ind}this.{prop.Name} = new System.Collections.ObjectModel.ObservableCollection<{dictType}>({conversionExpr});");
                            else
                                psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}({conversionExpr});");
                        }
                        else
                        {
                            // Regular collection handling
                            string sel = string.Empty;
                            var elemConv = ValueFromProto("e", elem, "e1");
                            if (elemConv != "e")
                            {
                                sel = elemConv == "ProtoStateConverters.FromProto(e)"
                                    ? ".Select(ProtoStateConverters.FromProto)"
                                    : $".Select(e => {elemConv})";
                            }

                            if (named.TypeKind == TypeKind.Interface)
                                psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}{sel}.ToList();");
                            else if (named.ConstructedFrom.ToDisplayString() == "System.Collections.ObjectModel.ObservableCollection<T>")
                                psb.AppendLine($"{ind}this.{prop.Name} = new System.Collections.ObjectModel.ObservableCollection<{elem.ToDisplayString()}>(state.{protoStateFieldName}{sel});");
                            else if (DerivesFromObservableCollection(named))
                            {
                                psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}();");
                                psb.AppendLine($"{ind}foreach (var e in state.{protoStateFieldName}{sel}) this.{prop.Name}.Add(e);");
                            }
                            else
                                psb.AppendLine($"{ind}this.{prop.Name} = new {prop.TypeString}(state.{protoStateFieldName}{sel});");
                        }
                    }
                    else
                    {
                        var assign = ValueFromProto($"state.{protoStateFieldName}", prop.FullTypeSymbol, "val");
                        psb.AppendLine($"{ind}this.{prop.Name} = {assign};");
                    }
                }
                else if (prop.FullTypeSymbol is IArrayTypeSymbol arr)
                {
                    var elem = arr.ElementType;
                    if (elem != null)
                    {
                        string sel = string.Empty;
                        var elemConv = ValueFromProto("e", elem, "e1");
                        if (elemConv != "e")
                        {
                            sel = elemConv == "ProtoStateConverters.FromProto(e)"
                                ? ".Select(ProtoStateConverters.FromProto)"
                                : $".Select(e => {elemConv})";
                        }
                        psb.AppendLine($"{ind}this.{prop.Name} = state.{protoStateFieldName}{sel}.ToArray();");
                    }
                }
                else
                {
                    var assign = ValueFromProto($"state.{protoStateFieldName}", prop.FullTypeSymbol, "val");
                    psb.AppendLine($"{ind}this.{prop.Name} = {assign};");
                }
            }
            return psb.ToString();
        }

        var assignmentsPing = BuildPropertyAssignments(32);
        var assignmentsInit = BuildPropertyAssignments(16);

        var commandMethods = new StringBuilder();
        foreach (var cmd in cmds)
        {
            string cmdMethodNameForLog = cmd.MethodName;
            string baseMethodName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            string paramListWithType = string.Join(", ", cmd.Parameters.Select(p => $"{p.TypeString} {GeneratorHelpers.LowercaseFirst(p.Name)}"));
            string requestCreation = $"new {protoNs}.{baseMethodName}Request()";
            if (cmd.Parameters.Any())
            {
                var paramAssignments = cmd.Parameters.Select(p =>
                {
                    var varName = GeneratorHelpers.LowercaseFirst(p.Name);
                    string expr = ValueToProto(varName, p.FullTypeSymbol!);
                    return $"{GeneratorHelpers.ToPascalCase(p.Name)} = {expr}"; 
                });
                requestCreation = $"new {protoNs}.{baseMethodName}Request {{ {string.Join(", ", paramAssignments)} }}";
            }
            string methodSignature = cmd.IsAsync ? $"private async Task RemoteExecute_{baseMethodName}Async({paramListWithType})" : $"private void RemoteExecute_{baseMethodName}({paramListWithType})";
            commandMethods.AppendLine($"        {methodSignature}");
            commandMethods.AppendLine("        {");
            string earlyExit = "return;";
            commandMethods.AppendLine($"            if (!_isInitialized || _isDisposed) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Not initialized or disposed, command {cmdMethodNameForLog} skipped.\"); {earlyExit} }}");
            commandMethods.AppendLine($"            Debug.WriteLine(\"[ClientProxy:{vmName}] Executing command {cmdMethodNameForLog} remotely...\");");
            commandMethods.AppendLine("            try");
            commandMethods.AppendLine("            {");
            var grpcMethod = baseMethodName + "Async";
            if (cmd.IsAsync)
                commandMethods.AppendLine($"                await _grpcClient.{grpcMethod}({requestCreation}, cancellationToken: _cts.Token);");
            else
                commandMethods.AppendLine($"                _ = _grpcClient.{grpcMethod}({requestCreation}, cancellationToken: _cts.Token);");
            commandMethods.AppendLine("            }");
            commandMethods.AppendLine($"            catch (RpcException ex) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Error executing command {cmdMethodNameForLog}: \" + ex.Status.StatusCode + \" - \" + ex.Status.Detail); }}");
            commandMethods.AppendLine($"            catch (OperationCanceledException) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Command {cmdMethodNameForLog} cancelled.\"); }}");
            commandMethods.AppendLine($"            catch (Exception ex) {{ Debug.WriteLine(\"[ClientProxy:{vmName}] Unexpected error executing command {cmdMethodNameForLog}: \" + ex.Message); }}");
            commandMethods.AppendLine("        }");
            commandMethods.AppendLine();
        }

        var result = GeneratorHelpers.ReplacePlaceholders(template, new Dictionary<string, string>
        {
            ["<<AUTO_GENERATED_HEADER>>"] = headerSb.ToString().TrimEnd(),
            ["<<NAMESPACE>>"] = ns,
            ["<<VIEW_MODEL_NAME>>"] = vmName,
            ["<<VIEW_MODEL_NS>>"] = vmNamespace ?? "Generated.ViewModels",
            ["<<PROTO_NS>>"] = protoNs,
            ["<<SERVICE_NAME>>"] = serviceName,
            ["<<PROPERTY_DECLARATIONS>>"] = propertyDecls.ToString(),
            ["<<COMMAND_DECLARATIONS>>"] = commandDecls.ToString(),
            ["<<COMMAND_INITIALIZATIONS>>"] = commandInits.ToString(),
            ["<<PROPERTY_ASSIGNMENTS_INIT>>"] = assignmentsInit,
            ["<<PROPERTY_ASSIGNMENTS_PING>>"] = assignmentsPing,
            ["<<COMMAND_METHODS>>"] = commandMethods.ToString(),
            ["<<PROPERTY_UPDATE_CASES>>"] = BuildPropertyUpdateCases(props, vmName),
        });

        return result;
    }

    private static string BuildPropertyUpdateCases(List<PropertyInfo> props, string vmName)
    {
        var sb = new StringBuilder();
        foreach (var prop in props)
        {
            string wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(prop.FullTypeSymbol!);
            string csharpPropName = prop.Name;
            sb.AppendLine($"                                   case nameof({csharpPropName}):");
            if (wkt == "StringValue")
            {
                var typeDisplayString = prop.FullTypeSymbol.ToDisplayString();
                switch (typeDisplayString)
                {
                    case "System.Decimal" or "decimal":
                        sb.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = decimal.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    case "System.Char" or "char":
                        sb.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<StringValue>().Value[0]; break;");
                        break;
                    case "System.Guid":
                        sb.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = Guid.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    case "System.DateOnly":
                        sb.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = DateOnly.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    case "System.TimeOnly":
                        sb.AppendLine($"                     if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = TimeOnly.Parse(update.NewValue.Unpack<StringValue>().Value); break;");
                        break;
                    default:
                        sb.AppendLine($"                 if (update.NewValue!.Is(StringValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<StringValue>().Value; break;");
                        break;
                }
            }
            else if (wkt == "Int32Value")
                sb.AppendLine($"                     if (update.NewValue!.Is(Int32Value.Descriptor)) this.{csharpPropName} = ({prop.TypeString})update.NewValue.Unpack<Int32Value>().Value; break;");
            else if (wkt == "Int64Value")
                sb.AppendLine($"                     if (update.NewValue!.Is(Int64Value.Descriptor)) this.{csharpPropName} = ({prop.TypeString})update.NewValue.Unpack<Int64Value>().Value; break;");
            else if (wkt == "UInt32Value")
                sb.AppendLine($"                    if (update.NewValue!.Is(UInt32Value.Descriptor)) this.{csharpPropName} = ({prop.TypeString})update.NewValue.Unpack<UInt32Value>().Value; break;");
            else if (wkt == "UInt64Value")
                sb.AppendLine($"                    if (update.NewValue!.Is(UInt64Value.Descriptor)) this.{csharpPropName} = ({prop.TypeString})update.NewValue.Unpack<UInt64Value>().Value; break;");
            else if (wkt == "DoubleValue")
                sb.AppendLine($"                    if (update.NewValue!.Is(DoubleValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<DoubleValue>().Value; break;");
            else if (wkt == "FloatValue")
            {
                var typeDisplayString = prop.FullTypeSymbol.ToDisplayString();
                if (typeDisplayString == "System.Half")
                    sb.AppendLine($"                     if (update.NewValue!.Is(FloatValue.Descriptor)) this.{csharpPropName} = (Half)update.NewValue.Unpack<FloatValue>().Value; break;");
                else
                    sb.AppendLine($"                     if (update.NewValue!.Is(FloatValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<FloatValue>().Value; break;");
            }
            else if (wkt == "BoolValue")
                sb.AppendLine($"                    if (update.NewValue!.Is(BoolValue.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<BoolValue>().Value; break;");
            else if (wkt == "Timestamp")
                sb.AppendLine($"                    if (update.NewValue!.Is(Timestamp.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<Timestamp>().ToDateTime(); break;");
            else if (wkt == "Duration")
                sb.AppendLine($"                    if (update.NewValue!.Is(Duration.Descriptor)) this.{csharpPropName} = update.NewValue.Unpack<Duration>().ToTimeSpan(); break;");
            else
                sb.AppendLine($"                                       Debug.WriteLine(\"[ClientProxy:{vmName}] Unpacking for {prop.Name} with WKT {wkt} not fully implemented or is Any.\"); break;");
        }
        return sb.ToString();
    }
}
