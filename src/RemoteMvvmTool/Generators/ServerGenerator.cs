using GrpcRemoteMvvmModelUtil;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RemoteMvvmTool.Generators;

public static class ServerGenerator
{
    public static string Generate(string vmName, string protoNs, string serviceName, List<PropertyInfo> props, List<CommandInfo> cmds, string viewModelNamespace, string runType = "wpf")
    {
        var headerSb = new StringBuilder();
        GeneratorHelpers.AppendAutoGeneratedHeader(headerSb);

        // Generate additional usings based on run type
        var additionalUsings = "";
        if (runType == "wpf") 
            additionalUsings = "using System.Windows.Threading;";
        else if (runType == "winforms") 
            additionalUsings = "using System.Windows.Forms;";

        // Generate dispatcher fields
        var dispatcherFields = "";
        if (runType == "wpf") 
            dispatcherFields = "    private readonly Dispatcher? _dispatcher;";
        else if (runType == "winforms") 
            dispatcherFields = "    private readonly Control _dispatcher;";

        // Generate dispatcher parameters
        var dispatcherParams = "";
        if (runType == "wpf") 
            dispatcherParams = "Dispatcher dispatcher, ";
        else if (runType == "winforms") 
            dispatcherParams = "Control dispatcher, ";

        // Generate dispatcher assignments
        var dispatcherAssignments = "";
        if (runType == "wpf")
        {
            dispatcherAssignments = "        _dispatcher = dispatcher ?? throw new ArgumentNullException(nameof(dispatcher));";
        }
        else if (runType == "winforms")
        {
            dispatcherAssignments = "        _dispatcher = dispatcher ?? throw new ArgumentNullException(nameof(dispatcher));";
        }

        // Generate property mappings
        var propertyMappings = GeneratePropertyMappings(props, vmName, protoNs, viewModelNamespace);

        // Generate update property dispatcher logic
        var updatePropertyDispatcherLogic = GenerateUpdatePropertyDispatcherLogic(runType);

        // Generate command methods
        var commandMethods = GenerateCommandMethods(cmds, vmName, protoNs, runType);

        // Generate console mode setup
        var consoleModeSetup = @"        // **GRPC THREADING FIX**: gRPC services run on background threads, so PropertyChanged events
        // must fire on the current thread to reach streaming subscribers, not be marshaled to UI thread
        try
        {
            var fireOnUIThreadProperty = _viewModel.GetType().GetProperty(""FirePropertyChangedOnUIThread"");
            if (fireOnUIThreadProperty != null && fireOnUIThreadProperty.CanWrite)
            {
                fireOnUIThreadProperty.SetValue(_viewModel, false);
                Debug.WriteLine(""[GrpcService:" + vmName + @"] Set FirePropertyChangedOnUIThread = false for gRPC compatibility"");
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine(""[GrpcService:" + vmName + @"] Warning: Could not set FirePropertyChangedOnUIThread: "" + ex.Message);
        }";

        var template = GeneratorHelpers.LoadTemplate("RemoteMvvmTool.Resources.ServerTemplate.tmpl");
        
        return GeneratorHelpers.ReplacePlaceholders(template, new Dictionary<string, string>
        {
            ["<<AUTO_GENERATED_HEADER>>"] = headerSb.ToString().TrimEnd(),
            ["<<PROTO_NS>>"] = protoNs,
            ["<<VIEWMODEL_NAMESPACE>>"] = viewModelNamespace,
            ["<<ADDITIONAL_USINGS>>"] = additionalUsings,
            ["<<VIEWMODEL_NAME>>"] = vmName,
            ["<<SERVICE_NAME>>"] = serviceName,
            ["<<DISPATCHER_FIELDS>>"] = dispatcherFields,
            ["<<DISPATCHER_PARAMS>>"] = dispatcherParams,
            ["<<DISPATCHER_ASSIGNMENTS>>"] = dispatcherAssignments,
            ["<<CONSOLE_MODE_SETUP>>"] = consoleModeSetup,
            ["<<PROPERTY_MAPPINGS>>"] = propertyMappings,
            ["<<UPDATE_PROPERTY_DISPATCHER_LOGIC>>"] = updatePropertyDispatcherLogic,
            ["<<COMMAND_METHODS>>"] = commandMethods + GeneratePingMethod(vmName, protoNs),
        });
    }

    private static string GeneratePropertyMappings(List<PropertyInfo> props, string vmName, string protoNs, string viewModelNamespace)
    {
        var sb = new StringBuilder();
        
        string KeyToProto(string expr, ITypeSymbol type)
        {
            if (type.TypeKind == TypeKind.Enum) return $"(int){expr}";
            return GeneratorHelpers.GetProtoWellKnownTypeFor(type) switch
            {
                "Int32Value" => $"(int){expr}",
                "UInt32Value" => $"(uint){expr}",
                "Int64Value" => expr,
                "UInt64Value" => expr,
                "StringValue" => type.ToDisplayString() switch
                {
                    "System.Guid" => $"{expr}.ToString()",
                    "System.Char" or "char" => $"{expr}.ToString()",
                    "System.Decimal" or "decimal" => $"{expr}.ToString()",
                    _ => expr
                },
                "FloatValue" => type.ToDisplayString() == "System.Half" ? $"(float){expr}" : expr,
                _ => expr
            };
        }

        string ValueToProto(string expr, ITypeSymbol type, string prefix)
        {
            if (GeneratorHelpers.TryGetDictionaryTypeArgs(type, out var k, out var v))
                return DictToProto(expr, k!, v!, prefix + "_kv");
            if (type.TypeKind == TypeKind.Enum) return $"(int){expr}";
            var wkt = GeneratorHelpers.GetProtoWellKnownTypeFor(type);
            if (wkt == "Timestamp") return $"Timestamp.FromDateTime({expr}.ToUniversalTime())";
            if (!GeneratorHelpers.IsWellKnownType(type))
                return $"{viewModelNamespace}.ProtoStateConverters.ToProto({expr})";
            
            // Handle special type conversions
            var typeDisplayString = type.ToDisplayString();
            return typeDisplayString switch
            {
                "System.Half" => $"(float){expr}",
                "System.Char" or "char" => $"{expr}.ToString()",
                "System.Guid" => $"{expr}.ToString()",
                "System.Decimal" or "decimal" => $"{expr}.ToString()",
                _ => expr
            };
        }

        string DictToProto(string dictExpr, ITypeSymbol kType, ITypeSymbol vType, string kvVar)
        {
            if (GeneratorHelpers.CanUseProtoMap(kType, vType))
            {
                string keySel = KeyToProto($"{kvVar}.Key", kType);
                string valSel = ValueToProto($"{kvVar}.Value", vType, $"{kvVar}1");
                return $"{dictExpr}.ToDictionary({kvVar} => {keySel}, {kvVar} => {valSel})";
            }
            else
            {
                string entryName = GeneratorHelpers.GetDictionaryEntryName(kType, vType);
                string keySel = KeyToProto($"{kvVar}.Key", kType);
                string valSel = ValueToProto($"{kvVar}.Value", vType, $"{kvVar}1");
                
                if (GeneratorHelpers.TryGetDictionaryTypeArgs(vType, out _, out _))
                    return $"{dictExpr}.Select({kvVar} => new {entryName} {{ Key = {keySel}, Value = {{ {valSel} }} }})";
                else if (GeneratorHelpers.TryGetEnumerableElementType(vType, out _) || vType is IArrayTypeSymbol || GeneratorHelpers.TryGetMemoryElementType(vType, out _))
                {
                    // Value type is a collection - need to populate the repeated field
                    return $"{dictExpr}.Select({kvVar} => {{ var entry = new {entryName} {{ Key = {keySel} }}; if ({kvVar}.Value != null) entry.Value.AddRange({valSel}); return entry; }})";
                }
                else
                    return $"{dictExpr}.Select({kvVar} => new {entryName} {{ Key = {keySel}, Value = {valSel} }})";
            }
        }

        foreach (var p in props)
        {
            sb.AppendLine($"        // Mapping property: {p.Name} to state.{p.Name}");
            sb.AppendLine("        try");
            sb.AppendLine("        {");
            sb.AppendLine($"            var propValue = _viewModel.{p.Name};");
            if (p.FullTypeSymbol is INamedTypeSymbol named && named.IsGenericType)
            {
                if (GeneratorHelpers.TryGetDictionaryTypeArgs(named, out _, out _))
                {
                    var keyType = named.TypeArguments[0];
                    var valueType = named.TypeArguments[1];
                    if (GeneratorHelpers.CanUseProtoMap(keyType, valueType))
                    {
                        // Use protobuf map - add individual key-value pairs
                        string keySel = KeyToProto("kv.Key", keyType);
                        string valSel = ValueToProto("kv.Value", valueType, "kv1");
                        sb.AppendLine($"            if (propValue != null)");
                        sb.AppendLine($"            {{");
                        sb.AppendLine($"                foreach (var kv in propValue)");
                        sb.AppendLine($"                    state.{p.Name}.Add({keySel}, {valSel});");
                        sb.AppendLine($"            }}");
                    }
                    else
                    {
                        // Use repeated message entries - can use AddRange
                        var dictExpr = DictToProto("propValue", keyType, valueType, "kv");
                        sb.AppendLine($"            if (propValue != null) state.{p.Name}.AddRange({dictExpr});");
                    }
                }
                else if (GeneratorHelpers.TryGetMemoryElementType(named, out var memElem))
                {
                    if (memElem?.SpecialType == SpecialType.System_Byte)
                        sb.AppendLine($"            if (!propValue.IsEmpty) state.{p.Name} = Google.Protobuf.ByteString.CopyFrom(propValue.ToArray());");
                    else
                        sb.AppendLine($"            if (!propValue.IsEmpty) state.{p.Name}.AddRange(propValue.ToArray());");
                }
                else if (GeneratorHelpers.TryGetEnumerableElementType(named, out var elem))
                {
                    // Special handling for collections of dictionaries
                    if (elem is INamedTypeSymbol elemNamed && elemNamed.IsGenericType &&
                        GeneratorHelpers.TryGetDictionaryTypeArgs(elemNamed, out var elemKeyType, out var elemValueType) &&
                        GeneratorHelpers.CanUseProtoMap(elemKeyType!, elemValueType!))
                    {
                        // This is a collection of dictionaries - use map-containing message approach
                        string dictMapName = GeneratorHelpers.GetDictionaryEntryName(elemKeyType!, elemValueType!) + "Map";
                        string keySel = KeyToProto("kv.Key", elemKeyType!);
                        string valSel = ValueToProto("kv.Value", elemValueType!, "kv1");
                        
                        sb.AppendLine($"            if (propValue != null)");
                        sb.AppendLine($"            {{");
                        sb.AppendLine($"                foreach (var dict in propValue)");
                        sb.AppendLine($"                {{");
                        sb.AppendLine($"                    var mapMsg = new {protoNs}.{dictMapName}();");
                        sb.AppendLine($"                    if (dict != null)");
    sb.AppendLine($"                    {{");
    sb.AppendLine($"                        foreach (var kv in dict)");
    sb.AppendLine($"                            mapMsg.Entries.Add({keySel}, {valSel});");
    sb.AppendLine($"                    }}");
    sb.AppendLine($"                    state.{p.Name}.Add(mapMsg);");
    sb.AppendLine($"                }}");
    sb.AppendLine($"            }}");
                    }
                    else
                    {
                        // Regular collection handling
                        string expr = "propValue";
                        if (!elem!.IsValueType)
                            expr += ".Where(e => e != null)";
                        if (elem.TypeKind == TypeKind.Enum)
                            expr += ".Select(e => (int)e)";
                        else if (!GeneratorHelpers.IsWellKnownType(elem))
                            expr += $".Select({viewModelNamespace}.ProtoStateConverters.ToProto).Where(s => s != null)";
                        sb.AppendLine($"            if (propValue != null) state.{p.Name}.AddRange({expr});");
                    }
                }
                else
                {
                    if (p.FullTypeSymbol.TypeKind == TypeKind.Enum)
                        sb.AppendLine($"            state.{p.Name} = (int)propValue;");
                    else if (!GeneratorHelpers.IsWellKnownType(p.FullTypeSymbol))
                        sb.AppendLine($"            state.{p.Name} = {viewModelNamespace}.ProtoStateConverters.ToProto(propValue);");
                    else
                        sb.AppendLine($"            state.{p.Name} = propValue;");
                }
            }
            else if (p.FullTypeSymbol is IArrayTypeSymbol arr)
            {
                var elem = arr.ElementType;
                if (elem.SpecialType == SpecialType.System_Byte)
                {
                    sb.AppendLine($"            if (propValue != null) state.{p.Name} = Google.Protobuf.ByteString.CopyFrom(propValue);");
                }
                else
                {
                    string expr = "propValue";
                    if (!elem.IsValueType)
                        expr += ".Where(e => e != null)";
                    if (elem.TypeKind == TypeKind.Enum)
                        expr += ".Select(e => (int)e)";
                    else if (!GeneratorHelpers.IsWellKnownType(elem))
                        expr += $".Select({viewModelNamespace}.ProtoStateConverters.ToProto).Where(s => s != null)";
                    sb.AppendLine($"            if (propValue != null) state.{p.Name}.AddRange({expr});");
                }
            }
            else
            {
                // Handle special type conversions for well-known types
                var typeDisplayString = p.FullTypeSymbol.ToDisplayString();
                var assignment = typeDisplayString switch
                {
                    "System.DateTime" => $"Google.Protobuf.WellKnownTypes.Timestamp.FromDateTime(propValue.ToUniversalTime())",
                    "System.Half" => $"(float)propValue",
                    "System.Char" or "char" => $"propValue.ToString()",
                    "System.Guid" => $"propValue.ToString()",
                    "System.Decimal" or "decimal" => $"propValue.ToString()",
                    _ => "propValue"
                };
                
                if (p.FullTypeSymbol.TypeKind == TypeKind.Enum)
                    sb.AppendLine($"            state.{p.Name} = (int)propValue;");
                else if (!GeneratorHelpers.IsWellKnownType(p.FullTypeSymbol))
                    sb.AppendLine($"            state.{p.Name} = {viewModelNamespace}.ProtoStateConverters.ToProto(propValue);");
                else
                    sb.AppendLine($"            state.{p.Name} = {assignment};");
            }
            sb.AppendLine("        }");
            sb.AppendLine($"        catch (Exception ex) {{ Debug.WriteLine(\"[GrpcService:{vmName}] Error mapping property {p.Name} to state.{p.Name}: \" + ex.ToString()); }}");
        }
        
        return sb.ToString();
    }

    private static string GenerateUpdatePropertyDispatcherLogic(string runType)
    {
        return runType switch
        {
            "wpf" => """
        if (_dispatcher != null)
        {
            await _dispatcher.InvokeAsync(() =>
            {
                response = UpdatePropertyValueInternal(request);
            });
        }
        else
        {
            response.Success = false;
            response.ErrorMessage = "Dispatcher not available";
        }
""",
            "winforms" => """
        if (_dispatcher != null)
        {
            await Task.Run(() => _dispatcher.Invoke(new Action(() =>
            {
                response = UpdatePropertyValueInternal(request);
            })));
        }
        else
        {
            response.Success = false;
            response.ErrorMessage = "Dispatcher not available";
        }
""",
            _ => "        response = UpdatePropertyValueInternal(request);"
        };
    }

    private static string GenerateCommandMethods(List<CommandInfo> cmds, string vmName, string protoNs, string runType)
    {
        var sb = new StringBuilder();
        
        foreach (var cmd in cmds)
        {
            var baseName = cmd.MethodName.EndsWith("Async", StringComparison.Ordinal)
                ? cmd.MethodName[..^5]
                : cmd.MethodName;
            var reqType = baseName + "Request";
            var respType = baseName + "Response";
            
            sb.AppendLine();
            sb.AppendLine($"    public override Task<{protoNs}.{respType}> {baseName}({protoNs}.{reqType} request, ServerCallContext context)");
            sb.AppendLine("    {");
            sb.AppendLine($"        var response = new {protoNs}.{respType}();");
            sb.AppendLine("        ");
            sb.AppendLine("        try");
            sb.AppendLine("        {");
            
            // Add command type reference comment for better testability
            if (cmd.Parameters.Count > 0)
            {
                var paramTypes = string.Join(", ", cmd.Parameters.Select(p => p.TypeString));
                if (cmd.Parameters.Count == 1)
                {
                    sb.AppendLine($"            // Executes command: IRelayCommand<{paramTypes}>");
                }
                else
                {
                    sb.AppendLine($"            // Executes command: IRelayCommand<({paramTypes})>");
                }
            }
            else
            {
                sb.AppendLine("            // Executes command: IRelayCommand");
            }
            
            if (runType == "wpf")
            {
                sb.AppendLine("            if (_dispatcher != null)");
                sb.AppendLine("            {");
                sb.AppendLine("                _dispatcher.Invoke(() =>");
                sb.AppendLine("                {");
                if (cmd.Parameters.Count > 0)
                {
                    // Generate parameter extraction
                    foreach (var p in cmd.Parameters)
                    {
                        var paramName = GeneratorHelpers.ToCamelCase(p.Name);
                        if (p.FullTypeSymbol!.TypeKind == TypeKind.Enum)
                        {
                            sb.AppendLine($"                    var {paramName} = ({p.TypeString})request.{GeneratorHelpers.ToPascalCase(p.Name)};");
                        }
                        else
                        {
                            sb.AppendLine($"                    var {paramName} = request.{GeneratorHelpers.ToPascalCase(p.Name)};");
                        }
                    }
                    
                    var paramList = string.Join(", ", cmd.Parameters.Select(p => GeneratorHelpers.ToCamelCase(p.Name)));
                    if (cmd.Parameters.Count == 1)
                    {
                        sb.AppendLine($"                    _viewModel.{cmd.CommandPropertyName}?.Execute({paramList});");
                    }
                    else
                    {
                        sb.AppendLine($"                    _viewModel.{cmd.CommandPropertyName}?.Execute(({paramList}));");
                    }
                }
                else
                {
                    sb.AppendLine($"                    _viewModel.{cmd.CommandPropertyName}?.Execute(null);");
                }
                sb.AppendLine("                });");
                sb.AppendLine("            }");
            }
            else if (runType == "winforms")
            {
                sb.AppendLine("            if (_dispatcher != null)");
                sb.AppendLine("            {");
                sb.AppendLine("                _dispatcher.Invoke(new Action(() =>");
                sb.AppendLine("                {");
                if (cmd.Parameters.Count > 0)
                {
                    // Generate parameter extraction
                    foreach (var p in cmd.Parameters)
                    {
                        var paramName = GeneratorHelpers.ToCamelCase(p.Name);
                        if (p.FullTypeSymbol!.TypeKind == TypeKind.Enum)
                        {
                            sb.AppendLine($"                    var {paramName} = ({p.TypeString})request.{GeneratorHelpers.ToPascalCase(p.Name)};");
                        }
                        else
                        {
                            sb.AppendLine($"                    var {paramName} = request.{GeneratorHelpers.ToPascalCase(p.Name)};");
                        }
                    }
                    
                    var paramList = string.Join(", ", cmd.Parameters.Select(p => GeneratorHelpers.ToCamelCase(p.Name)));
                    if (cmd.Parameters.Count == 1)
                    {
                        sb.AppendLine($"                    _viewModel.{cmd.CommandPropertyName}?.Execute({paramList});");
                    }
                    else
                    {
                        sb.AppendLine($"                    _viewModel.{cmd.CommandPropertyName}?.Execute(({paramList}));");
                    }
                }
                else
                {
                    sb.AppendLine($"                    _viewModel.{cmd.CommandPropertyName}?.Execute(null);");
                }
                sb.AppendLine("                }));");
                sb.AppendLine("            }");
            }
            else
            {
                // Console mode - direct execution
                if (cmd.Parameters.Count > 0)
                {
                    // Generate parameter extraction
                    foreach (var p in cmd.Parameters)
                    {
                        var paramName = GeneratorHelpers.ToCamelCase(p.Name);
                        if (p.FullTypeSymbol!.TypeKind == TypeKind.Enum)
                        {
                            sb.AppendLine($"            var {paramName} = ({p.TypeString})request.{GeneratorHelpers.ToPascalCase(p.Name)};");
                        }
                        else
                        {
                            sb.AppendLine($"            var {paramName} = request.{GeneratorHelpers.ToPascalCase(p.Name)};");
                        }
                    }
                    
                    var paramList = string.Join(", ", cmd.Parameters.Select(p => GeneratorHelpers.ToCamelCase(p.Name)));
                    if (cmd.Parameters.Count == 1)
                    {
                        sb.AppendLine($"            _viewModel.{cmd.CommandPropertyName}?.Execute({paramList});");
                    }
                    else
                    {
                        sb.AppendLine($"            _viewModel.{cmd.CommandPropertyName}?.Execute(({paramList}));");
                    }
                }
                else
                {
                    sb.AppendLine($"            _viewModel.{cmd.CommandPropertyName}?.Execute(null);");
                }
            }
            
            sb.AppendLine($"            Debug.WriteLine(\"[GrpcService:{vmName}] Executed command {baseName}\");");
            sb.AppendLine("        }");
            sb.AppendLine("        catch (Exception ex)");
            sb.AppendLine("        {");
            sb.AppendLine($"            Debug.WriteLine(\"[GrpcService:{vmName}] Error executing command {baseName}: \" + ex);");
            sb.AppendLine($"            _logger?.LogError(ex, \"Error executing command {baseName}\");");
            sb.AppendLine("        }");
            sb.AppendLine("        ");
            sb.AppendLine("        return Task.FromResult(response);");
            sb.AppendLine("    }");
        }
        
        return sb.ToString();
    }

    private static string GeneratePingMethod(string vmName, string protoNs)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine();
        sb.AppendLine($"    public override Task<{protoNs}.ConnectionStatusResponse> Ping(Google.Protobuf.WellKnownTypes.Empty request, ServerCallContext context)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var response = new {protoNs}.ConnectionStatusResponse");
        sb.AppendLine("        {{");
        sb.AppendLine($"            Status = {protoNs}.ConnectionStatus.Connected");
        sb.AppendLine("        };");
        sb.AppendLine("        ");
        sb.AppendLine($"        Debug.WriteLine(\"[GrpcService:{vmName}] Ping received, responding with Connected status\");");
        sb.AppendLine("        return Task.FromResult(response);");
        sb.AppendLine("    }");
        
        return sb.ToString();
    }
}
