// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

namespace HPSystemsTools.ViewModels
{
    public partial class HP3LSThermalTestViewModel : IEquatable<HP3LSThermalTestViewModel>
    {
        private static readonly string[] __eqProps = new []{"Instructions","CpuTemperatureThreshold","CpuLoadThreshold","CpuLoadTimeSpan","Zones","TestSettings","ShowDescription","ShowReadme"};

        public bool Equals(HP3LSThermalTestViewModel? other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return DeepDiff(other).Count == 0;
        }
        public override bool Equals(object? obj) => Equals(obj as HP3LSThermalTestViewModel);

        public override int GetHashCode()
        {
            var hc = new HashCode();
            foreach (var n in __eqProps) { try { var v = GetType().GetProperty(n)?.GetValue(this); if (v != null) hc.Add(v); } catch { } }
            return hc.ToHashCode();
        }

        public List<string> DeepDiff(HP3LSThermalTestViewModel? other)
        {
            var diffs = new List<string>();
            if (other == null) { diffs.Add("<other null>"); return diffs; }
            foreach (var n in __eqProps)
            {
                object? a=null,b=null; bool okA=false, okB=false;
                try { a = GetType().GetProperty(n)?.GetValue(this); okA=true; } catch { }
                try { b = other.GetType().GetProperty(n)?.GetValue(other); okB=true; } catch { }
                if (!okA || !okB) { diffs.Add($"{n}: inaccessible"); continue; }
                if (!ValuesEqual(a,b)) diffs.Add($"{n}: '{FormatVal(a)}' != '{FormatVal(b)}'");
            }
            return diffs;
        }

        private static bool ValuesEqual(object? a, object? b)
        {
            if (ReferenceEquals(a,b)) return true;
            if (a is null || b is null) return false;
            if (a.GetType()!=b.GetType()) return false;
            switch (a)
            {
                case string sa: return sa==(string)b;
                case Guid ga: return ga.Equals((Guid)b);
                case DateTime dta: return dta.ToUniversalTime().Ticks==((DateTime)b).ToUniversalTime().Ticks;
                case DateOnly doa: return doa.DayNumber==((DateOnly)b).DayNumber;
                case TimeOnly toa: return toa.Ticks==((TimeOnly)b).Ticks;
                case decimal deca: return deca==(decimal)b;
                case double da: return Math.Abs(da-(double)b)<1e-9;
                case float fa: return Math.Abs(fa-(float)b)<1e-6f;
                case System.Collections.IDictionary dictA:
                    var dictB = (System.Collections.IDictionary)b; if (dictA.Count!=dictB.Count) return false; foreach (var key in dictA.Keys){ if (!dictB.Contains(key)) return false; if (!ValuesEqual(dictA[key], dictB[key])) return false;} return true;
                case System.Collections.IEnumerable enA when a is not string:
                    var listA = enA.Cast<object?>().ToList(); var listB = ((System.Collections.IEnumerable)b).Cast<object?>().ToList(); if (listA.Count!=listB.Count) return false; for (int i=0;i<listA.Count;i++) if (!ValuesEqual(listA[i], listB[i])) return false; return true;
            }
            if (a.GetType().IsValueType) return a.Equals(b);
            var props = a.GetType().GetProperties(System.Reflection.BindingFlags.Public|System.Reflection.BindingFlags.Instance).Where(p=>p.CanRead && p.GetIndexParameters().Length==0);
            foreach (var p in props){ object? va=null,vb=null; try { va=p.GetValue(a); vb=p.GetValue(b);} catch { } if (!ValuesEqual(va,vb)) return false; }
            return true;
        }

        private static string FormatVal(object? v)
        {
            if (v==null) return "<null>";
            if (v is string s) return s;
            if (v is DateTime dt) return dt.ToUniversalTime().ToString("o");
            if (v is System.Collections.IEnumerable en && v is not string) return "["+string.Join(",", en.Cast<object?>().Select(FormatVal))+ "]"; 
            return v.ToString() ?? string.Empty;
        }
    }
}
