// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

import { HP3LSThermalTestViewModelServiceClient } from './generated/HP3LSThermalTestViewModelServiceServiceClientPb';
import { HP3LSThermalTestViewModelState, UpdatePropertyValueRequest, UpdatePropertyValueResponse, SubscribeRequest, PropertyChangeNotification, ConnectionStatusResponse, ConnectionStatus, StateChangedRequest, CancelTestRequest } from './generated/HP3LSThermalTestViewModelService_pb.js';
import * as grpcWeb from 'grpc-web';
import { Empty } from 'google-protobuf/google/protobuf/empty_pb';
import { Any } from 'google-protobuf/google/protobuf/any_pb';
import { BoolValue, Int32Value, StringValue } from 'google-protobuf/google/protobuf/wrappers_pb';
import { Timestamp } from 'google-protobuf/google/protobuf/timestamp_pb';

// Enum Mappings
// Enum mapping for HP.Telemetry.Zone
export const ZoneMap: Record<number, string> = {
  0: 'Other',
  1: 'CPUZ_0',
  2: 'CPUZ_1',
  3: 'GFXZ_0',
  4: 'EXTZ_0',
  5: 'LOCZ_0',
  6: 'BATZ_0',
  7: 'CHGZ_0',
  8: 'SK1Z_0',
  9: 'SK2Z_0',
  10: 'PCHZ_0'
};

export function getZoneDisplay(value: number): string {
  return ZoneMap[value] || value.toString();
}

// Enum mapping for HPSystemsTools.Models.ThermalStateEnum
export const ThermalStateEnumMap: Record<number, string> = {
  0: 'Unknown',
  1: 'MaybeRunningHot',
  2: 'MaybeOk',
  3: 'RunningHot',
  4: 'Ok',
  5: 'StressLevelExceeded',
  6: 'Pass',
  7: 'Fail',
  8: 'MaybePass',
  9: 'MaybeFail',
  10: 'CheckInProgress',
  11: 'Reset'
};

export function getThermalStateEnumDisplay(value: number): string {
  return ThermalStateEnumMap[value] || value.toString();
}

export interface ThermalZoneState {
  zone: number;
  readonly isActive: boolean;
  readonly deviceName: string;
  readonly temperature: number;
  readonly processorLoad: number;
  readonly fanSpeed: number;
  readonly secondsInState: number;
  readonly firstSeenInState: Date;
  readonly progress: number;
  background: string;
  readonly status: number;
  readonly state: number;
  readonly stateDescription: string;
  readonly statusDescription: string;
}

export interface TestSettingsState {
  cpuTemperatureThreshold: number;
  cpuLoadThreshold: number;
  cpuLoadTimeSpan: number;
}

export const readOnlyMemberMap: Record<string, Set<string>> = {
  ThermalZoneState: new Set(['isActive', 'deviceName', 'temperature', 'processorLoad', 'fanSpeed', 'secondsInState', 'firstSeenInState', 'progress', 'status', 'state', 'stateDescription', 'statusDescription']),
};

export class HP3LSThermalTestViewModelRemoteClient {
    private readonly grpcClient: HP3LSThermalTestViewModelServiceClient;
    private propertyStream?: grpcWeb.ClientReadableStream<PropertyChangeNotification>;
    private pingIntervalId?: any;
    private changeCallbacks: Array<() => void> = [];
    private updateDebounceMap = new Map<string, any>(); // Internal debouncing (any for cross-platform compatibility)

    instructions: string;
    cpuTemperatureThreshold: number;
    cpuLoadThreshold: number;
    cpuLoadTimeSpan: number;
    zones: ThermalZoneState[];
    testSettings: TestSettingsState;
    showDescription: boolean;
    showReadme: boolean;
    private readonly readOnlyProps = new Set<string>(['Instructions', 'Zones', 'TestSettings']);
    connectionStatus: string = 'Unknown';

    addChangeListener(cb: ((isFromServer?: boolean) => void) | (() => void)): void {
        this.changeCallbacks.push(cb as () => void);
    }

    private notifyChange(isFromServer: boolean = false): void {
        this.changeCallbacks.forEach(cb => {
            try {
                // Pass the server flag to callbacks that support it
                if (cb.length > 0) {
                    (cb as any)(isFromServer);
                } else {
                    cb();
                }
            } catch (err) {
                console.warn('Error in change callback:', err);
            }
        });
    }

    constructor(grpcClient: HP3LSThermalTestViewModelServiceClient) {
        this.grpcClient = grpcClient;
    }

    async initializeRemote(): Promise<void> {
        const state = await this.grpcClient.getState(new Empty());
        this.instructions = (state as any).getInstructions();
        this.cpuTemperatureThreshold = (state as any).getCpuTemperatureThreshold();
        this.cpuLoadThreshold = (state as any).getCpuLoadThreshold();
        this.cpuLoadTimeSpan = (state as any).getCpuLoadTimeSpan();
        this.zones = (state as any).getZonesList().map((v:any) => { const obj = v.toObject(); obj.firstSeenInState = v.getFirstSeenInState()?.toDate(); return obj; });
        this.testSettings = (() => { const v = (state as any).getTestSettings(); return v ? v.toObject() : undefined; })();
        this.showDescription = (state as any).getShowDescription();
        this.showReadme = (state as any).getShowReadme();
        this.connectionStatus = 'Connected';
        this.notifyChange();
        this.startListeningToPropertyChanges();
        this.startPingLoop();
    }

    async refreshState(): Promise<void> {
        const state = await this.grpcClient.getState(new Empty());
        this.instructions = (state as any).getInstructions();
        this.cpuTemperatureThreshold = (state as any).getCpuTemperatureThreshold();
        this.cpuLoadThreshold = (state as any).getCpuLoadThreshold();
        this.cpuLoadTimeSpan = (state as any).getCpuLoadTimeSpan();
        this.zones = (state as any).getZonesList().map((v:any) => { const obj = v.toObject(); obj.firstSeenInState = v.getFirstSeenInState()?.toDate(); return obj; });
        this.testSettings = (() => { const v = (state as any).getTestSettings(); return v ? v.toObject() : undefined; })();
        this.showDescription = (state as any).getShowDescription();
        this.showReadme = (state as any).getShowReadme();
        this.notifyChange();
    }

    async updatePropertyValue(propertyName: string, value: any): Promise<UpdatePropertyValueResponse> {
        if (this.readOnlyProps?.has(propertyName)) {
            const res = new UpdatePropertyValueResponse();
            res.setSuccess(false);
            res.setErrorMessage(`Property ${propertyName} is read-only`);
            return res;
        }
        const req = new UpdatePropertyValueRequest();
        req.setPropertyName(propertyName);
        req.setArrayIndex(-1); // Default to -1 for non-array properties
        req.setNewValue(this.createAnyValue(value));
        const response = await this.grpcClient.updatePropertyValue(req);
        
        // If the response indicates success, update the local property value
        if (typeof response.getSuccess === 'function' && response.getSuccess()) {
            this.updateLocalProperty(propertyName, value);
        }
        
        return response;
    }

    // Debounced property update to prevent rapid-fire server calls
    updatePropertyValueDebounced(propertyName: string, value: any, delayMs: number = 200): void {
        if (this.readOnlyProps?.has(propertyName)) return;
        // Clear existing timeout for this property
        const existingTimeout = this.updateDebounceMap.get(propertyName);
        if (existingTimeout) {
            clearTimeout(existingTimeout);
        }
        
        // Set new timeout
        const timeout = setTimeout(async () => {
            try {
                console.log(`Sending debounced update: ${propertyName} = ${value}`);
                await this.updatePropertyValue(propertyName, value);
            } catch (err) {
                console.error(`Error updating ${propertyName}:`, err);
            } finally {
                this.updateDebounceMap.delete(propertyName);
            }
        }, delayMs);
        
        this.updateDebounceMap.set(propertyName, timeout);
    }

    // Enhanced updatePropertyValue with support for complex scenarios
    async updatePropertyValueAdvanced(
        propertyName: string, 
        value: any, 
        options?: {
            propertyPath?: string;
            collectionKey?: string;
            arrayIndex?: number;
            operationType?: 'set' | 'add' | 'remove' | 'clear' | 'insert';
        }
    ): Promise<UpdatePropertyValueResponse> {
        const req = new UpdatePropertyValueRequest();
        req.setPropertyName(propertyName);
        req.setNewValue(this.createAnyValue(value));
        
        if (options?.propertyPath) req.setPropertyPath(options.propertyPath);
        if (options?.collectionKey) req.setCollectionKey(options.collectionKey);
        if (options?.arrayIndex !== undefined) req.setArrayIndex(options.arrayIndex);
        if (options?.operationType) req.setOperationType(options.operationType);
        
        const response = await this.grpcClient.updatePropertyValue(req);
        
        // If the response indicates success, update the local property value
        if (typeof response.getSuccess === 'function' && response.getSuccess()) {
            this.updateLocalProperty(propertyName, value);
        }
        
        return response;
    }

    async stateChanged(state: any): Promise<void> {
        const req = new StateChangedRequest();
        req.setState(state);
        await this.grpcClient.stateChanged(req);
    }
    async cancelTest(): Promise<void> {
        const req = new CancelTestRequest();
        await this.grpcClient.cancelTest(req);
    }

    private startPingLoop(): void {
        if (this.pingIntervalId) return;
        this.pingIntervalId = setInterval(async () => {
            try {
                const resp: ConnectionStatusResponse = await this.grpcClient.ping(new Empty());
                if (resp.getStatus() === ConnectionStatus.CONNECTED) {
                    if (this.connectionStatus !== 'Connected') {
                        await this.refreshState();
                    }
                    this.connectionStatus = 'Connected';
                } else {
                    this.connectionStatus = 'Disconnected';
                }
            } catch {
                this.connectionStatus = 'Disconnected';
            }
            this.notifyChange();
        }, 5000);
    }

    private startListeningToPropertyChanges(): void {
        const req = new SubscribeRequest();
        req.setClientId(Math.random().toString());
        this.propertyStream = this.grpcClient.subscribeToPropertyChanges(req);
        this.propertyStream.on('data', (update: PropertyChangeNotification) => {
            const anyVal = update.getNewValue();
            const path = update.getPropertyPath();
            if (path) {
                const value = this.unpackAny(anyVal);
                this.setByPath(this, path, value);
            } else {
            switch (update.getPropertyName()) {
                case 'Instructions':
                    this.instructions = anyVal?.unpack(StringValue.deserializeBinary, 'google.protobuf.StringValue')?.getValue();
                    break;
                case 'CpuTemperatureThreshold':
                    this.cpuTemperatureThreshold = anyVal?.unpack(Int32Value.deserializeBinary, 'google.protobuf.Int32Value')?.getValue();
                    break;
                case 'CpuLoadThreshold':
                    this.cpuLoadThreshold = anyVal?.unpack(Int32Value.deserializeBinary, 'google.protobuf.Int32Value')?.getValue();
                    break;
                case 'CpuLoadTimeSpan':
                    this.cpuLoadTimeSpan = anyVal?.unpack(Int32Value.deserializeBinary, 'google.protobuf.Int32Value')?.getValue();
                    break;
                case 'ShowDescription':
                    this.showDescription = anyVal?.unpack(BoolValue.deserializeBinary, 'google.protobuf.BoolValue')?.getValue();
                    break;
                case 'ShowReadme':
                    this.showReadme = anyVal?.unpack(BoolValue.deserializeBinary, 'google.protobuf.BoolValue')?.getValue();
                    break;
            }
            }
            // Notify with server flag - UI can update but won't send back to server
            this.notifyChange(true);
        });
        this.propertyStream.on('error', () => {
            this.propertyStream = undefined;
            setTimeout(() => this.startListeningToPropertyChanges(), 1000);
        });
        this.propertyStream.on('end', () => {
            this.propertyStream = undefined;
            setTimeout(() => this.startListeningToPropertyChanges(), 1000);
        });
    }

    private setByPath(target: any, path: string, value: any): void {
        const parts = path.split('.');
        let obj: any = target;
        for (let i = 0; i < parts.length; i++) {
            const m = /(\w+)(?:\[(\d+)\])?/.exec(parts[i]);
            if (!m) return;
            const key = m[1].charAt(0).toLowerCase() + m[1].slice(1);
            const idx = m[2] !== undefined ? parseInt(m[2], 10) : undefined;
            if (i === parts.length - 1) {
                if (idx !== undefined) {
                    if (Array.isArray(obj[key])) obj[key][idx] = value;
                } else {
                    obj[key] = value;
                }
            } else {
                obj = idx !== undefined ? obj[key][idx] : obj[key];
                if (obj === undefined) return;
            }
        }
    }

    private unpackAny(anyVal: Any | undefined): any {
        if (!anyVal) return undefined;
        const typeUrl = anyVal.getTypeUrl();
        switch (typeUrl) {
            case 'type.googleapis.com/google.protobuf.StringValue':
                return anyVal.unpack(StringValue.deserializeBinary, 'google.protobuf.StringValue')?.getValue();
            case 'type.googleapis.com/google.protobuf.Int32Value':
                return anyVal.unpack(Int32Value.deserializeBinary, 'google.protobuf.Int32Value')?.getValue();
            case 'type.googleapis.com/google.protobuf.BoolValue':
                return anyVal.unpack(BoolValue.deserializeBinary, 'google.protobuf.BoolValue')?.getValue();
            case 'type.googleapis.com/google.protobuf.Timestamp':
                return anyVal.unpack(Timestamp.deserializeBinary, 'google.protobuf.Timestamp')?.toDate();
            default:
                return undefined;
        }
    }

    private createAnyValue(value: any): Any {
        if (value == null) {
            const empty = new Empty();
            const anyValue = new Any();
            anyValue.pack(empty.serializeBinary(), 'google.protobuf.Empty');
            return anyValue;
        }
        
        const anyValue = new Any();
        
        switch (typeof value) {
            case 'string': {
                const str = new StringValue();
                str.setValue(value);
                anyValue.pack(str.serializeBinary(), 'google.protobuf.StringValue');
                return anyValue;
            }
            case 'number': {
                if (Number.isInteger(value)) {
                    const int32 = new Int32Value();
                    int32.setValue(value);
                    anyValue.pack(int32.serializeBinary(), 'google.protobuf.Int32Value');
                    return anyValue;
                }
            }
            case 'boolean': {
                const bool = new BoolValue();
                bool.setValue(value);
                anyValue.pack(bool.serializeBinary(), 'google.protobuf.BoolValue');
                return anyValue;
            }
            default: {
                const empty = new Empty();
                anyValue.pack(empty.serializeBinary(), 'google.protobuf.Empty');
                return anyValue;
            }
        }
    }

    dispose(): void {
        if (this.propertyStream) {
            this.propertyStream.cancel();
            this.propertyStream = undefined;
        }
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
            this.pingIntervalId = undefined;
        }
        // Clear any pending debounced updates
        this.updateDebounceMap.forEach((timeout) => clearTimeout(timeout));
        this.updateDebounceMap.clear();
    }

    private updateLocalProperty(propertyName: string, value: any): void {
        const camelCasePropertyName = this.toCamelCase(propertyName);
        
        // Update the local property if it exists
        if (camelCasePropertyName in this) {
            (this as any)[camelCasePropertyName] = value;
            this.notifyChange();
        }
    }

    private toCamelCase(str: string): string {
        return str.charAt(0).toLowerCase() + str.slice(1);
    }
}
