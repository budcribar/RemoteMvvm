// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

import { HP3LSThermalTestViewModelServiceClient } from './generated/HP3LSThermalTestViewModelServiceClientPb';
import { HP3LSThermalTestViewModelRemoteClient } from './HP3LSThermalTestViewModelRemoteClient';
import './components/gauge';
import './components/readme';
import './components/thermal-zone';
import './components/thermal-main';
import './components/notification';

const grpcHost = 'http://localhost:50052';
const grpcClient = new HP3LSThermalTestViewModelServiceClient(grpcHost);
const vm = new HP3LSThermalTestViewModelRemoteClient(grpcClient);

// Centralized error reporting
function handleError(err: any, context?: string) {
    try {
        const msg = err?.message ?? String(err);
        console.error(context ? `${context}:` : 'Error:', err);
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = context ? `${context}: ${msg}` : msg;
        }
    } catch { /* no-op */ }
}

// Add debouncing to prevent rapid-fire updates
const updateDebounceMap = new Map<string, NodeJS.Timeout>();

function debounceUpdate(propertyName: string, value: any, delayMs: number = 200) {
    // Clear existing timeout for this property
    const existingTimeout = updateDebounceMap.get(propertyName);
    if (existingTimeout) {
        clearTimeout(existingTimeout);
    }
    
    // Set new timeout
    const timeout = setTimeout(async () => {
        try {
            console.log(`Sending debounced update: ${propertyName} = ${value}`);
            await vm.updatePropertyValue(propertyName, value);
        } catch (err) {
            handleError(err, `Update ${propertyName}`);
        } finally {
            updateDebounceMap.delete(propertyName);
        }
    }, delayMs);
    
    updateDebounceMap.set(propertyName, timeout);
}

function computeMaxTempC(deviceName: string | undefined): number {
    const pct = vm?.testSettings?.cpuTemperatureThreshold ?? 100;
    // If a DTS map is available, prefer that:
    // const dts = vm?.testSettings?.dTS as Record<string, number> | undefined;
    // const max = deviceName && dts ? dts[deviceName] : undefined;
    // if (typeof max === 'number' && Number.isFinite(max)) {
    //   return Math.round(max * (pct / 100));
    // }
    // Fallback assumption: device max ~100C, threshold is a percent of that
    return Math.round(100 * (pct / 100));
}

function buildZonesPayload(): any[] {
    const zonesArr = Array.isArray(vm.zoneList) ? vm.zoneList : [];
    return zonesArr
        .filter((z: any) => z && (z.isActive === undefined || !!z.isActive))
        .map((z: any) => ({
            active: z.isActive ?? true,
            background: z.background ?? '#fafafa',
            status: String(z.status ?? ''),
            state: String(z.state ?? ''),
            progress: Number(z.progress ?? 0),
            zone: z.deviceName ? String(z.deviceName) : String(z.zone ?? ''),
            fanSpeed: Number(z.fanSpeed ?? 0),
            deviceName: z.deviceName ?? 'Device',
            temperature: Number(z.temperature ?? 0),
            maxTemp: computeMaxTempC(z.deviceName),
            processorLoadName: 'Processor Load',
            processorLoad: Number(z.processorLoad ?? 0),
            cpuLoadThreshold: Number(vm?.testSettings?.cpuLoadThreshold ?? 100),
            // stateDescriptions: can be added if available
        }));
}

async function render() {
    const main = document.querySelector('x-thermal-main') as HTMLElement | null;
    if (main) {
        // Toggle sections
        main.setAttribute('show-description', String(!!vm.showDescription));
    // Reflect server ShowReadme for button label state (inline readme stays hidden by component)
    main.setAttribute('show-readme', String(!!vm.showReadme));

        // Sliders from TestSettings
        const ts = vm.testSettings ?? ({} as any);
        if (ts.cpuTemperatureThreshold != null) main.setAttribute('temp-threshold', String(ts.cpuTemperatureThreshold));
        if (ts.cpuLoadThreshold != null) main.setAttribute('cpu-load-threshold', String(ts.cpuLoadThreshold));
        if (ts.cpuLoadTimeSpan != null) main.setAttribute('cpu-load-time', String(ts.cpuLoadTimeSpan));

        // Zones
        try {
            const zones = buildZonesPayload();
            main.setAttribute('zones', JSON.stringify(zones));
        } catch (err) {
            handleError(err, 'Render zones');
        }

        // Ensure README modal visibility matches server state
        try {
            ensureReadmeModal(!!vm.showReadme, main);
        } catch (err) {
            handleError(err, 'Render README modal');
        }
    }
    const statusEl = document.getElementById('connection-status');
    if (statusEl) statusEl.textContent = vm.connectionStatus;
}

function ensureReadmeModal(open: boolean, main: HTMLElement) {
    let note = document.querySelector('x-notification') as (HTMLElement & { show?: () => void; hide?: () => void; __onCloseHandler?: (ev: Event) => void; }) | null;
    if (open) {
        if (!note) {
            note = document.createElement('x-notification') as any;
            document.body.appendChild(note);
        }
        note.setAttribute('title', 'README');
        // Ensure one slotted x-readme exists
        let readme = note.querySelector('x-readme') as HTMLElement | null;
        if (!readme) {
            readme = document.createElement('x-readme');
            note.appendChild(readme);
        }
        // Mirror show-previous flag
        const showPrev = main.getAttribute('readme-show-previous') === 'true';
        if (showPrev) readme.setAttribute('show-previous', 'true'); else readme.removeAttribute('show-previous');

        // Setup close handler for user-initiated actions
        if (!note.__onCloseHandler) {
            note.__onCloseHandler = async () => {
                try {
                    await vm.updatePropertyValue('ShowReadme', false);
                } catch (err) {
                    handleError(err, 'Close README -> server update');
                }
            };
            note.addEventListener('close', note.__onCloseHandler);
        }
        if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
    } else if (note) {
        // Close without dispatching 'close' event to avoid feedback loop to server
        note.removeAttribute('open');
    }
}

async function init() {
    try {
        await vm.initializeRemote();
        vm.addChangeListener(render);
        render();
    } catch (err) {
        handleError(err, 'Initialize remote');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    init();
    const main = document.querySelector('x-thermal-main');
    if (main) {
        main.addEventListener('change-temp-threshold', async (e: any) => {
            const newValue = Number(e?.detail?.value ?? 0);
            const currentValue = vm?.testSettings?.cpuTemperatureThreshold;
            // Only update if value actually changed
            if (newValue !== currentValue) {
                debounceUpdate('CpuTemperatureThreshold', newValue);
            }
        });
        main.addEventListener('change-cpu-load-threshold', async (e: any) => {
            const newValue = Number(e?.detail?.value ?? 0);
            const currentValue = vm?.testSettings?.cpuLoadThreshold;
            if (newValue !== currentValue) {
                debounceUpdate('CpuLoadThreshold', newValue);
            }
        });
        main.addEventListener('change-cpu-load-time', async (e: any) => {
            const newValue = Number(e?.detail?.value ?? 0);
            const currentValue = vm?.testSettings?.cpuLoadTimeSpan;
            if (newValue !== currentValue) {
                debounceUpdate('CpuLoadTimeSpan', newValue);
            }
        });
        main.addEventListener('toggle-readme', async (e: any) => {
            const newValue = Boolean(e?.detail?.value);
            const currentValue = vm.showReadme;
            if (newValue !== currentValue) {
                debounceUpdate('ShowReadme', newValue);
            }
        });
        main.addEventListener('toggle-description', async (e: any) => {
            const newValue = Boolean(e?.detail?.value);
            const currentValue = vm.showDescription;
            if (newValue !== currentValue) {
                debounceUpdate('ShowDescription', newValue);
            }
        });
        main.addEventListener('cancel', async () => {
            try { await vm.cancelTest(); }
            catch (err) { handleError(err, 'Cancel test'); }
        });
    }
});
