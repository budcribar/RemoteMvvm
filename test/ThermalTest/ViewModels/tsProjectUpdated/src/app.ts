// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

import { HP3LSThermalTestViewModelServiceClient } from './generated/HP3LSThermalTestViewModelServiceServiceClientPb';
import { HP3LSThermalTestViewModelRemoteClient } from './HP3LSThermalTestViewModelRemoteClient';
import './components/gauge';
import './components/readme';
import './components/thermal-zone';
import './components/thermal-main';
import './components/notification';

const grpcHost = 'http://localhost:50052';
const grpcClient = new HP3LSThermalTestViewModelServiceClient(grpcHost);
const vm = new HP3LSThermalTestViewModelRemoteClient(grpcClient);

// Centralized error reporting
function handleError(err: any, context?: string) {
    try {
        const msg = err?.message ?? String(err);
        console.error(context ? `${context}:` : 'Error:', err);
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = context ? `${context}: ${msg}` : msg;
        }
    } catch { /* no-op */ }
}



function computeMaxTempC(deviceName: string | undefined): number {
    const pct = vm?.testSettings?.cpuTemperatureThreshold ?? 100;
    // If a DTS map is available, prefer that:
    // const dts = vm?.testSettings?.dTS as Record<string, number> | undefined;
    // const max = deviceName && dts ? dts[deviceName] : undefined;
    // if (typeof max === 'number' && Number.isFinite(max)) {
    //   return Math.round(max * (pct / 100));
    // }
    // Fallback assumption: device max ~100C, threshold is a percent of that
    return Math.round(100 * (pct / 100));
}

function buildZonesPayload(): any[] {
    const zonesArr = Array.isArray(vm.zoneList) ? vm.zoneList : [];
    return zonesArr
        .filter((z: any) => z && (z.isActive === undefined || !!z.isActive))
        .map((z: any) => ({
            active: z.isActive ?? true,
            background: z.background ?? '#fafafa',
            status: String(z.status ?? ''),
            state: String(z.state ?? ''),
            progress: Number(z.progress ?? 0),
            zone: z.deviceName ? String(z.deviceName) : String(z.zone ?? ''),
            fanSpeed: Number(z.fanSpeed ?? 0),
            deviceName: z.deviceName ?? 'Device',
            temperature: Number(z.temperature ?? 0),
            maxTemp: computeMaxTempC(z.deviceName),
            processorLoadName: 'Processor Load',
            processorLoad: Number(z.processorLoad ?? 0),
            cpuLoadThreshold: Number(vm?.testSettings?.cpuLoadThreshold ?? 100),
            // stateDescriptions: can be added if available
        }));
}

async function render() {
    const main = document.querySelector('x-thermal-main') as HTMLElement | null;
    if (main) {
        // Toggle sections
        main.setAttribute('show-description', String(!!vm.showDescription));
        main.setAttribute('show-readme', String(!!vm.showReadme));

        // Set instructions from VM if available
        if (typeof vm.instructions === 'string') {
            main.setAttribute('instructions', vm.instructions);
        } else {
            main.removeAttribute('instructions');
        }

        if (vm.cpuTemperatureThreshold != null) main.setAttribute('temp-threshold', String(vm.cpuTemperatureThreshold));
        if (vm.cpuLoadThreshold != null) main.setAttribute('cpu-load-threshold', String(vm.cpuLoadThreshold));
        if (vm.cpuLoadTimeSpan != null) main.setAttribute('cpu-load-time', String(vm.cpuLoadTimeSpan));

        // Zones
        try {
            const zones = buildZonesPayload();
            main.setAttribute('zones', JSON.stringify(zones));
        } catch (err) {
            handleError(err, 'Render zones');
        }

        // Ensure README modal visibility matches server state
        try {
            ensureReadmeModal(!!vm.showReadme, main);
        } catch (err) {
            handleError(err, 'Render README modal');
        }
        // Ensure Description modal visibility matches server state
        try {
            ensureDescriptionModal(!!vm.showDescription, main);
        } catch (err) {
            handleError(err, 'Render Description modal');
        }
    }
    const statusEl = document.getElementById('connection-status');
    if (statusEl) statusEl.textContent = vm.connectionStatus;
}

function ensureDescriptionModal(open: boolean, main: HTMLElement) {
    let note = document.querySelector('x-notification[data-desc]') as (HTMLElement & { show?: () => void; hide?: () => void; __onCloseHandler?: (ev: Event) => void; }) | null;
    if (open) {
        if (!note) {
            note = document.createElement('x-notification') as any;
            note.setAttribute('data-desc', '');
            document.body.appendChild(note);
        }
        note.setAttribute('title', 'Description');
        // Ensure one slotted div for instructions
        let descDiv = note.querySelector('div[data-desc-content]') as HTMLElement | null;
        if (!descDiv) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('data-desc-content', '');
            note.appendChild(descDiv);
        }
        descDiv.textContent = vm.instructions || '';

        // Setup close handler for user-initiated actions
        if (!note.__onCloseHandler) {
            note.__onCloseHandler = async () => {
                try {
                    await vm.updatePropertyValue('ShowDescription', false);
                } catch (err) {
                    handleError(err, 'Close Description -> server update');
                }
            };
            note.addEventListener('close', note.__onCloseHandler);
        }
        if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
    } else if (note) {
        note.removeAttribute('open');
    }
}

function ensureReadmeModal(open: boolean, main: HTMLElement) {
    let note = document.querySelector('x-notification') as (HTMLElement & { show?: () => void; hide?: () => void; __onCloseHandler?: (ev: Event) => void; }) | null;
    if (open) {
        if (!note) {
            note = document.createElement('x-notification') as any;
            document.body.appendChild(note);
        }
        note.setAttribute('title', 'README');
        // Ensure one slotted x-readme exists
        let readme = note.querySelector('x-readme') as HTMLElement | null;
        if (!readme) {
            readme = document.createElement('x-readme');
            note.appendChild(readme);
        }
        // Mirror show-previous flag
        const showPrev = main.getAttribute('readme-show-previous') === 'true';
        if (showPrev) readme.setAttribute('show-previous', 'true'); else readme.removeAttribute('show-previous');

        // Setup close handler for user-initiated actions
        if (!note.__onCloseHandler) {
            note.__onCloseHandler = async () => {
                try {
                    await vm.updatePropertyValue('ShowReadme', false);
                } catch (err) {
                    handleError(err, 'Close README -> server update');
                }
            };
            note.addEventListener('close', note.__onCloseHandler);
        }
        if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
    } else if (note) {
        // Close without dispatching 'close' event to avoid feedback loop to server
        note.removeAttribute('open');
    }
}

async function init() {
    try {
        await vm.initializeRemote();
            // Add a 1-second polling timer for live updates (survives codegen)
        setInterval(() => {
            vm.refreshState().catch(() => {});
        }, 1000);
        vm.addChangeListener(render);
        render();
    } catch (err) {
        handleError(err, 'Initialize remote');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    init();
    (document.getElementById('instructions') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.instructions;
    // Only update if value actually changed
    if (newValue !== currentValue) {
        vm.updatePropertyValueDebounced('Instructions', newValue);
    }
});
(document.getElementById('cpuTemperatureThreshold') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.cpuTemperatureThreshold;
    // Only update if value actually changed
    if (Number(newValue) !== currentValue) {
        vm.updatePropertyValueDebounced('CpuTemperatureThreshold', Number(newValue));
    }
});
(document.getElementById('cpuLoadThreshold') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.cpuLoadThreshold;
    // Only update if value actually changed
    if (Number(newValue) !== currentValue) {
        vm.updatePropertyValueDebounced('CpuLoadThreshold', Number(newValue));
    }
});
(document.getElementById('cpuLoadTimeSpan') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.cpuLoadTimeSpan;
    // Only update if value actually changed
    if (Number(newValue) !== currentValue) {
        vm.updatePropertyValueDebounced('CpuLoadTimeSpan', Number(newValue));
    }
});
(document.getElementById('zoneList') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.zoneList;
    // Only update if value actually changed
    if (JSON.stringify(vm.zoneList) !== JSON.stringify(currentValue)) {
        vm.updatePropertyValueDebounced('ZoneList', JSON.parse(newValue));
    }
});
(document.getElementById('testSettings') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.testSettings;
    // Only update if value actually changed
    if (JSON.stringify(vm.testSettings) !== JSON.stringify(currentValue)) {
        vm.updatePropertyValueDebounced('TestSettings', JSON.parse(newValue));
    }
});
(document.getElementById('showDescription') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.showDescription;
    // Only update if value actually changed
    if (Boolean(newValue.toLowerCase() === 'true') !== currentValue) {
        vm.updatePropertyValueDebounced('ShowDescription', newValue.toLowerCase() === 'true');
    }
});
(document.getElementById('showReadme') as HTMLInputElement).addEventListener('change', (e) => {
    const newValue = (e.target as HTMLInputElement).value;
    const currentValue = vm.showReadme;
    // Only update if value actually changed
    if (Boolean(newValue.toLowerCase() === 'true') !== currentValue) {
        vm.updatePropertyValueDebounced('ShowReadme', newValue.toLowerCase() === 'true');
    }
});
(document.getElementById('stateChanged-btn') as HTMLButtonElement).addEventListener('click', async () => {
    try {
        await vm.stateChanged(undefined);
    } catch (err) {
        handleError(err, 'Execute StateChanged');
    }
});
(document.getElementById('cancelTest-btn') as HTMLButtonElement).addEventListener('click', async () => {
    try {
        await vm.cancelTest();
    } catch (err) {
        handleError(err, 'Execute CancelTest');
    }
});
});
