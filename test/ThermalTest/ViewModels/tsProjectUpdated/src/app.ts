// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

import { HP3LSThermalTestViewModelServiceClient } from './generated/HP3LSThermalTestViewModelServiceServiceClientPb';
import { HP3LSThermalTestViewModelRemoteClient } from './HP3LSThermalTestViewModelRemoteClient';
import './components/gauge';
import './components/readme';
import './components/thermal-zone';
import './components/thermal-main';
import './components/notification';

const grpcHost = 'http://localhost:50052';
const grpcClient = new HP3LSThermalTestViewModelServiceClient(grpcHost);
const vm = new HP3LSThermalTestViewModelRemoteClient(grpcClient);

// Centralized error reporting
function handleError(err: any, context?: string) {
    try {
        const msg = err?.message ?? String(err);
        console.error(context ? `${context}:` : 'Error:', err);
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = context ? `${context}: ${msg}` : msg;
        }
    } catch { /* no-op */ }
}

// Catch any unhandled promise rejections and global errors
window.addEventListener('unhandledrejection', (ev: PromiseRejectionEvent) => {
    handleError(ev.reason, 'Unhandled promise');
    ev.preventDefault?.();
});
window.addEventListener('error', (ev: ErrorEvent) => {
    handleError(ev.error ?? ev.message, 'Global error');
});

function computeMaxTempC(deviceName: string | undefined): number {
    const pct = vm?.testSettings?.cpuTemperatureThreshold ?? 100;
    // If a DTS map is available, prefer that:
    // const dts = vm?.testSettings?.dTS as Record<string, number> | undefined;
    // const max = deviceName && dts ? dts[deviceName] : undefined;
    // if (typeof max === 'number' && Number.isFinite(max)) {
    //   return Math.round(max * (pct / 100));
    // }
    // Fallback assumption: device max ~100C, threshold is a percent of that
    return Math.round(100 * (pct / 100));
}

function buildZonesPayload(): any[] {
    const zonesArr = Array.isArray(vm.zoneList) ? vm.zoneList : [];
    return zonesArr
        .filter((z: any) => z && (z.isActive === undefined || !!z.isActive))
        .map((z: any) => ({
            active: z.isActive ?? true,
            background: z.background ?? '#fafafa',
            status: String(z.status ?? ''),
            state: String(z.state ?? ''),
            progress: Number(z.progress ?? 0),
            zone: z.deviceName ? String(z.deviceName) : String(z.zone ?? ''),
            fanSpeed: Number(z.fanSpeed ?? 0),
            deviceName: z.deviceName ?? 'Device',
            temperature: Number(z.temperature ?? 0),
            maxTemp: computeMaxTempC(z.deviceName),
            processorLoadName: 'Processor Load',
            processorLoad: Number(z.processorLoad ?? 0),
            cpuLoadThreshold: Number(vm?.testSettings?.cpuLoadThreshold ?? 100),
            // stateDescriptions: can be added if available
        }));
}

function render() {
    const main = document.querySelector('x-thermal-main') as HTMLElement | null;
    if (main) {
        // Toggle sections
        main.setAttribute('show-description', String(!!vm.showDescription));
    // Reflect server ShowReadme for button label state (inline readme stays hidden by component)
    main.setAttribute('show-readme', String(!!vm.showReadme));

        // Sliders from TestSettings
        const ts = vm.testSettings ?? ({} as any);
        if (ts.cpuTemperatureThreshold != null) main.setAttribute('temp-threshold', String(ts.cpuTemperatureThreshold));
        if (ts.cpuLoadThreshold != null) main.setAttribute('cpu-load-threshold', String(ts.cpuLoadThreshold));
        if (ts.cpuLoadTimeSpan != null) main.setAttribute('cpu-load-time', String(ts.cpuLoadTimeSpan));

        // Zones
        try {
            const zones = buildZonesPayload();
            main.setAttribute('zones', JSON.stringify(zones));
        } catch (err) {
            handleError(err, 'Render zones');
        }

        // Ensure README modal visibility matches server state
        try {
            ensureReadmeModal(!!vm.showReadme, main);
        } catch (err) {
            handleError(err, 'Render README modal');
        }
    }
    const statusEl = document.getElementById('connection-status');
    if (statusEl) statusEl.textContent = vm.connectionStatus;
}

function ensureReadmeModal(open: boolean, main: HTMLElement) {
    let note = document.querySelector('x-notification') as HTMLElement & { show?: () => void; hide?: () => void } | null;
    if (open) {
        if (!note) {
            note = document.createElement('x-notification') as any;
            document.body.appendChild(note);
        }
        note.setAttribute('title', 'README');
        // Ensure one slotted x-readme exists
        let readme = note.querySelector('x-readme') as HTMLElement | null;
        if (!readme) {
            readme = document.createElement('x-readme');
            note.appendChild(readme);
        }
        // Mirror show-previous flag
        const showPrev = main.getAttribute('readme-show-previous') === 'true';
        if (showPrev) readme.setAttribute('show-previous', 'true'); else readme.removeAttribute('show-previous');

        const onClose = async () => {
            try {
                await vm.updatePropertyValue('ShowReadme', false);
            } catch (err) {
                handleError(err, 'Close README -> server update');
            }
        };
        // Reset close handler then show
        note.removeEventListener?.('close', onClose as any);
        note.addEventListener?.('close', onClose as any);
        if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
    } else if (note) {
        if (typeof note.hide === 'function') note.hide(); else note.removeAttribute('open');
    }
}

async function init() {
    try {
        await vm.initializeRemote();
        vm.addChangeListener(render);
        render();
    } catch (err) {
        handleError(err, 'Initialize remote');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    init();
    const main = document.querySelector('x-thermal-main');
    if (main) {
        main.addEventListener('change-temp-threshold', async (e: any) => {
            try {
                await vm.updatePropertyValue('CpuTemperatureThreshold', Number(e?.detail?.value ?? 0));
            } catch (err) { handleError(err, 'Update CpuTemperatureThreshold'); }
        });
        main.addEventListener('change-cpu-load-threshold', async (e: any) => {
            try {
                await vm.updatePropertyValue('CpuLoadThreshold', Number(e?.detail?.value ?? 0));
            } catch (err) { handleError(err, 'Update CpuLoadThreshold'); }
        });
        main.addEventListener('change-cpu-load-time', async (e: any) => {
            try {
                await vm.updatePropertyValue('CpuLoadTimeSpan', Number(e?.detail?.value ?? 0));
            } catch (err) { handleError(err, 'Update CpuLoadTimeSpan'); }
        });
        main.addEventListener('toggle-readme', async (e: any) => {
            try {
                const show = Boolean(e?.detail?.value);
                // Ask server to change ShowReadme; UI will react in render() via vm.showReadme
                await vm.updatePropertyValue('ShowReadme', show);
            } catch (err) { handleError(err, 'Toggle README'); }
        });
        main.addEventListener('toggle-description', async (e: any) => {
            try { await vm.updatePropertyValue('ShowDescription', Boolean(e?.detail?.value)); }
            catch (err) { handleError(err, 'Toggle description'); }
        });
        main.addEventListener('cancel', async () => {
            try { await vm.cancelTest(); }
            catch (err) { handleError(err, 'Cancel test'); }
        });
    }
});
