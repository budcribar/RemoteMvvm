// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

import { HP3LSThermalTestViewModelServiceClient } from './generated/HP3LSThermalTestViewModelServiceServiceClientPb';
import { HP3LSThermalTestViewModelRemoteClient } from './HP3LSThermalTestViewModelRemoteClient';
import './components/gauge';
import './components/readme';
import './components/thermal-zone';
import './components/thermal-main';
import './components/notification';

const grpcHost = 'http://localhost:50052';
const grpcClient = new HP3LSThermalTestViewModelServiceClient(grpcHost);
const vm = new HP3LSThermalTestViewModelRemoteClient(grpcClient);

// Centralized error reporting
function handleError(err: any, context?: string) {
    try {
        const msg = err?.message ?? String(err);
        console.error(context ? `${context}:` : 'Error:', err);
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = context ? `${context}: ${msg}` : msg;
        }
    } catch { /* no-op */ }
}

// Catch any unhandled promise rejections and global errors
window.addEventListener('unhandledrejection', (ev: PromiseRejectionEvent) => {
    handleError(ev.reason, 'Unhandled promise');
    ev.preventDefault?.();
});
window.addEventListener('error', (ev: ErrorEvent) => {
    handleError(ev.error ?? ev.message, 'Global error');
});

function computeMaxTempC(deviceName: string | undefined): number {
    const pct = vm?.testSettings?.cpuTemperatureThreshold ?? 100;
    // If a DTS map is available, prefer that:
    // const dts = vm?.testSettings?.dTS as Record<string, number> | undefined;
    // const max = deviceName && dts ? dts[deviceName] : undefined;
    // if (typeof max === 'number' && Number.isFinite(max)) {
    //   return Math.round(max * (pct / 100));
    // }
    // Fallback assumption: device max ~100C, threshold is a percent of that
    return Math.round(100 * (pct / 100));
}

function buildZonesPayload(): any[] {
    const zonesArr = Array.isArray(vm.zoneList) ? vm.zoneList : [];
    return zonesArr
        .filter((z: any) => z && (z.isActive === undefined || !!z.isActive))
        .map((z: any) => ({
            active: z.isActive ?? true,
            background: z.background ?? '#fafafa',
            status: String(z.status ?? ''),
            state: String(z.state ?? ''),
            progress: Number(z.progress ?? 0),
            zone: z.deviceName ? String(z.deviceName) : String(z.zone ?? ''),
            fanSpeed: Number(z.fanSpeed ?? 0),
            deviceName: z.deviceName ?? 'Device',
            temperature: Number(z.temperature ?? 0),
            maxTemp: computeMaxTempC(z.deviceName),
            processorLoadName: 'Processor Load',
            processorLoad: Number(z.processorLoad ?? 0),
            cpuLoadThreshold: Number(vm?.testSettings?.cpuLoadThreshold ?? 100),
            // stateDescriptions: can be added if available
        }));
}

function render() {
    const main = document.querySelector('x-thermal-main') as HTMLElement | null;
    if (main) {
        // Toggle sections
        main.setAttribute('show-description', String(!!vm.showDescription));
        main.setAttribute('show-readme', String(!!vm.showReadme));

        // Sliders from TestSettings
        const ts = vm.testSettings ?? ({} as any);
        if (ts.cpuTemperatureThreshold != null) main.setAttribute('temp-threshold', String(ts.cpuTemperatureThreshold));
        if (ts.cpuLoadThreshold != null) main.setAttribute('cpu-load-threshold', String(ts.cpuLoadThreshold));
        if (ts.cpuLoadTimeSpan != null) main.setAttribute('cpu-load-time', String(ts.cpuLoadTimeSpan));

        // Zones
        try {
            const zones = buildZonesPayload();
            main.setAttribute('zones', JSON.stringify(zones));
        } catch (err) {
            handleError(err, 'Render zones');
        }
    }
    const statusEl = document.getElementById('connection-status');
    if (statusEl) statusEl.textContent = vm.connectionStatus;
}

async function init() {
    try {
        await vm.initializeRemote();
        vm.addChangeListener(render);
        render();
    } catch (err) {
        handleError(err, 'Initialize remote');
    }
}

document.addEventListener('DOMContentLoaded', () => {
    init();
    const main = document.querySelector('x-thermal-main');
    if (main) {
        main.addEventListener('change-temp-threshold', async (e: any) => {
            try {
                await vm.updatePropertyValue('CpuTemperatureThreshold', Number(e?.detail?.value ?? 0));
            } catch (err) { handleError(err, 'Update CpuTemperatureThreshold'); }
        });
        main.addEventListener('change-cpu-load-threshold', async (e: any) => {
            try {
                await vm.updatePropertyValue('CpuLoadThreshold', Number(e?.detail?.value ?? 0));
            } catch (err) { handleError(err, 'Update CpuLoadThreshold'); }
        });
        main.addEventListener('change-cpu-load-time', async (e: any) => {
            try {
                await vm.updatePropertyValue('CpuLoadTimeSpan', Number(e?.detail?.value ?? 0));
            } catch (err) { handleError(err, 'Update CpuLoadTimeSpan'); }
        });
        main.addEventListener('toggle-readme', async (e: any) => {
            try {
                const show = Boolean(e?.detail?.value);
                await vm.updatePropertyValue('ShowReadme', show);
                if (show) {
                    // Create or reuse a notification element to show the README
                    let note = document.querySelector('x-notification') as any;
                    if (!note) {
                        note = document.createElement('x-notification') as any;
                        note.setAttribute('title', 'README');
                        const readme = document.createElement('x-readme');
                        // Mirror show-previous from main, if present
                        if ((main as HTMLElement).getAttribute('readme-show-previous') === 'true') {
                            readme.setAttribute('show-previous', 'true');
                        }
                        note.appendChild(readme);
                        document.body.appendChild(note);
                    }
                    // Always ensure we have a close handler bound
                    const onClose = async () => {
                        try {
                            // When the notification closes, turn off ShowReadme in VM and reflect to main
                            await vm.updatePropertyValue('ShowReadme', false);
                            (main as HTMLElement).setAttribute('show-readme', 'false');
                        } catch (err) { handleError(err, 'Close README'); }
                    };
                    // Avoid duplicate listeners by removing and re-adding
                    note.removeEventListener?.('close', onClose as any);
                    note.addEventListener?.('close', onClose as any);
                    if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
                } else {
                    // If toggled off, close any open notification
                    const note = document.querySelector('x-notification') as any;
                    if (note) {
                        if (typeof note.hide === 'function') note.hide(); else note.removeAttribute('open');
                    }
                }
            } catch (err) { handleError(err, 'Toggle README'); }
        });
        main.addEventListener('toggle-description', async (e: any) => {
            try { await vm.updatePropertyValue('ShowDescription', Boolean(e?.detail?.value)); }
            catch (err) { handleError(err, 'Toggle description'); }
        });
        main.addEventListener('cancel', async () => {
            try { await vm.cancelTest(); }
            catch (err) { handleError(err, 'Cancel test'); }
        });
    }
});
