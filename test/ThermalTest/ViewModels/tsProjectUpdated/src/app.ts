// <auto-generated>
// Generated by RemoteMvvmTool.
// </auto-generated>

import { HP3LSThermalTestViewModelServiceClient } from './generated/HP3LSThermalTestViewModelServiceServiceClientPb';
import { HP3LSThermalTestViewModelRemoteClient, ZoneMap } from './HP3LSThermalTestViewModelRemoteClient';
import './components/gauge';
import './components/readme';
import './components/thermal-zone';
import './components/thermal-main';
import './components/notification';

const grpcHost = 'http://localhost:50052';
const grpcClient = new HP3LSThermalTestViewModelServiceClient(grpcHost);
const vm = new HP3LSThermalTestViewModelRemoteClient(grpcClient);

// Centralized error reporting
function handleError(err: any, context?: string) {
    try {
        const msg = err?.message ?? String(err);
        console.error(context ? `${context}:` : 'Error:', err);
        const statusEl = document.getElementById('connection-status');
        if (statusEl) {
            statusEl.textContent = context ? `${context}: ${msg}` : msg;
        }
    } catch { /* no-op */ }
}



function computeMaxTempC(deviceName: string | undefined): number {
    const pct = vm?.testSettings?.cpuTemperatureThreshold ?? 100;
    // If a DTS map is available, prefer that:
    // const dts = vm?.testSettings?.dTS as Record<string, number> | undefined;
    // const max = deviceName && dts ? dts[deviceName] : undefined;
    // if (typeof max === 'number' && Number.isFinite(max)) {
    //   return Math.round(max * (pct / 100));
    // }
    // Fallback assumption: device max ~100C, threshold is a percent of that
    return Math.round(100 * (pct / 100));
}

function buildZonesPayload(): any[] {
    const zonesArr = Array.isArray(vm.zoneList) ? vm.zoneList : [];
    // Import the enum map
    const { ThermalStateEnumMap } = require('./HP3LSThermalTestViewModelRemoteClient');
    return zonesArr
        .filter((z: any) => z && (z.isActive === undefined || !!z.isActive))
        .map((z: any, idx: number) => {
            const statusStr = (z.status in ThermalStateEnumMap) ? ThermalStateEnumMap[z.status] : String(z.status ?? '');
            const stateStr = (z.state in ThermalStateEnumMap) ? ThermalStateEnumMap[z.state] : String(z.state ?? '');
            const displayedStatus = statusStr === 'CheckInProgress' ? stateStr : statusStr;
            return {
                active: z.isActive ?? true,
                background: z.background ?? '#fafafa',
                status: statusStr,
                state: stateStr,
                displayedStatus,
                progress: Number(z.progress ?? 0),
                zone: String(z.zone ?? ''),
                'zone-index': idx,
                fanSpeed: Number(z.fanSpeed ?? 0),
                deviceName: z.deviceName ?? 'Device',
                temperature: Number(z.temperature ?? 0),
                maxTemp: computeMaxTempC(z.deviceName),
                processorLoadName: 'Processor Load',
                processorLoad: Number(z.processorLoad ?? 0),
                cpuLoadThreshold: Number(vm?.testSettings?.cpuLoadThreshold ?? 100),
                statusDescription: z.statusDescription ?? '',
                stateDescription: z.stateDescription ?? '',
                // stateDescriptions: can be added if available
            };
        });
}

async function render() {
    const main = document.querySelector('x-thermal-main') as HTMLElement | null;
    if (main) {
        // Toggle sections
        main.setAttribute('show-description', String(!!vm.showDescription));
        main.setAttribute('show-readme', String(!!vm.showReadme));

        // Set instructions from VM if available
        if (typeof vm.instructions === 'string') {
            main.setAttribute('instructions', vm.instructions);
        } else {
            main.removeAttribute('instructions');
        }

        if (vm.cpuTemperatureThreshold != null) main.setAttribute('temp-threshold', String(vm.cpuTemperatureThreshold));
        if (vm.cpuLoadThreshold != null) main.setAttribute('cpu-load-threshold', String(vm.cpuLoadThreshold));
        if (vm.cpuLoadTimeSpan != null) main.setAttribute('cpu-load-time', String(vm.cpuLoadTimeSpan));

        // Pass zone map if available
        if (typeof ZoneMap === 'object' && ZoneMap !== null) {
            main.setAttribute('zone-map', JSON.stringify(ZoneMap));
        } else {
            main.removeAttribute('zone-map');
        }

        // Zones
        try {
            const zones = buildZonesPayload();
            main.setAttribute('zones', JSON.stringify(zones));
        } catch (err) {
            handleError(err, 'Render zones');
        }

        // Ensure README modal visibility matches server state
        try {
            ensureReadmeModal(!!vm.showReadme, main);
        } catch (err) {
            handleError(err, 'Render README modal');
        }
        // Ensure Description modal visibility matches server state
        try {
            ensureDescriptionModal(!!vm.showDescription, main);
        } catch (err) {
            handleError(err, 'Render Description modal');
        }
    }
    const statusEl = document.getElementById('connection-status');
    if (statusEl) statusEl.textContent = vm.connectionStatus;
}

function ensureDescriptionModal(open: boolean, main: HTMLElement) {
    let note = document.querySelector('x-notification[data-desc]') as (HTMLElement & { show?: () => void; hide?: () => void; __onCloseHandler?: (ev: Event) => void; }) | null;
    if (open) {
        if (!note) {
            note = document.createElement('x-notification') as any;
            note.setAttribute('data-desc', '');
            document.body.appendChild(note);
        }
        note.setAttribute('title', 'Description');
        // Ensure one slotted div for instructions
        let descDiv = note.querySelector('div[data-desc-content]') as HTMLElement | null;
        if (!descDiv) {
            descDiv = document.createElement('div');
            descDiv.setAttribute('data-desc-content', '');
            note.appendChild(descDiv);
        }
        descDiv.textContent = vm.instructions || '';

        // Setup close handler for user-initiated actions
        if (!note.__onCloseHandler) {
            note.__onCloseHandler = async () => {
                try {
                    await vm.updatePropertyValue('ShowDescription', false);
                } catch (err) {
                    handleError(err, 'Close Description -> server update');
                }
            };
            note.addEventListener('close', note.__onCloseHandler);
        }
        if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
    } else if (note) {
        note.removeAttribute('open');
    }
}

function ensureReadmeModal(open: boolean, main: HTMLElement) {
    let note = document.querySelector('x-notification[data-readme]') as (HTMLElement & { show?: () => void; hide?: () => void; __onCloseHandler?: (ev: Event) => void; }) | null;
    if (open) {
        if (!note) {
            note = document.createElement('x-notification') as any;
            note.setAttribute('data-readme', '');
            document.body.appendChild(note);
        }
        note.setAttribute('title', 'README');
        // Ensure one slotted x-readme exists
        let readme = note.querySelector('x-readme') as HTMLElement | null;
        if (!readme) {
            readme = document.createElement('x-readme');
            note.appendChild(readme);
        }
        // Mirror show-previous flag
        const showPrev = main.getAttribute('readme-show-previous') === 'true';
        if (showPrev) readme.setAttribute('show-previous', 'true'); else readme.removeAttribute('show-previous');

        // Setup close handler for user-initiated actions
        if (!note.__onCloseHandler) {
            note.__onCloseHandler = async () => {
                try {
                    await vm.updatePropertyValue('ShowReadme', false);
                } catch (err) {
                    handleError(err, 'Close README -> server update');
                }
            };
            note.addEventListener('close', note.__onCloseHandler);
        }
        if (typeof note.show === 'function') note.show(); else note.setAttribute('open', '');
    } else if (note) {
        // Close without dispatching 'close' event to avoid feedback loop to server
        note.removeAttribute('open');
    }
}

async function init() {
    try {
        await vm.initializeRemote();
        vm.addChangeListener(render);
        render();

        // Add event listeners for all VM properties
    const main = document.querySelector('x-thermal-main') as HTMLElement | null;
    if (main) wireMainEvents(main);
    } catch (err) {
        handleError(err, 'Initialize remote');
    }
// (removed extra closing brace)

function wireMainEvents(main: HTMLElement) {
    // Instructions (if editable)
    main.addEventListener('change-instructions', async (e: any) => {
        try {
            await vm.updatePropertyValue('Instructions', e?.detail?.value ?? '');
        } catch (err) {
            handleError(err, 'change-instructions');
        }
    });

    // CpuTemperatureThreshold
    main.addEventListener('change-temp-threshold', (e: any) => {
        vm.updatePropertyValueDebounced('CpuTemperatureThreshold', Number(e?.detail?.value));
    });

    // CpuLoadThreshold
    main.addEventListener('change-cpu-load-threshold', (e: any) => {
        vm.updatePropertyValueDebounced('CpuLoadThreshold', Number(e?.detail?.value));
    });

    // CpuLoadTimeSpan
    main.addEventListener('change-cpu-load-time', (e: any) => {
        vm.updatePropertyValueDebounced('CpuLoadTimeSpan', Number(e?.detail?.value));
    });

    // ShowDescription
    main.addEventListener('toggle-description', async (e: any) => {
        try {
            await vm.updatePropertyValue('ShowDescription', !!e?.detail?.value);
        } catch (err) {
            handleError(err, 'toggle-description');
        }
    });

    // ShowReadme
    main.addEventListener('toggle-readme', async (e: any) => {
        try {
            await vm.updatePropertyValue('ShowReadme', !!e?.detail?.value);
        } catch (err) {
            handleError(err, 'toggle-readme');
        }
    });

    // Cancel test
    main.addEventListener('cancel', async () => {
        try {
            await vm.cancelTest();
        } catch (err) {
            handleError(err, 'cancel');
        }
    });
}
}

document.addEventListener('DOMContentLoaded', () => {
    init();
    
});
